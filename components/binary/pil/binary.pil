// PIL State Machine that compute 256 bits operations:

//  ope │ opcode │ cin │ carry │ last │ ROWS  │ NOTES 
// ─────┼────────┼─────┼───────┼──────┼───────┼───────────────────────────────────
//  ADD │   0    │  0  │  X    │      │ 2**17 │ could use cIn to ADC
//  SUB │   1    │  0  │  X    │      │ 2**17 │ 
//  LT  │   2    │  0  │  X    │  X   │ 2**18 │ 
//  SLT │   3    │  0  │  X    │  X   │ 2**18 │ 
//  EQ  │   4    │  0  │  X    │  X   │ 2**18 │ 
//  AND │   5    │  0  │  X    │  X   │ 2**17 │ use carry to detect any bit one 
//  OR  │   6    │  0  │       │      │ 2**16 │ 
//  XOR │   7    │  0  │       │      │ 2**16 │ 
//  LT4 │   8    │  0  │  X    │  X   │ 2**18 │ TOTAL = 2**20 + 2**19 => 2**21
// ┄┄┄┄┄│┄┄┄┄┄┄┄┄│┄┄┄┄┄│┄┄┄┄┄┄┄│┄┄┄┄┄┄│┄┄┄┄┄┄┄│┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄ 

// example: 256 bits (32 bytes)
//
//  bytes/clk │ clk │ cols           │ area │ opens │ NOTES 
// ───────────┼─────┼────────────────┼──────┼───────┼───────────────────────────────────
//      2     │  16 │ 8 + 4*2 = 16   │ 256  │  17   │ 
//      4     │   8 │ 8 + 4*4 = 24   │ 192  │   9   │ 
//      8     │   4 │ 8 + 4*8 = 40   │ 160  │   5   │ 
//     16     │   2 │ 8 + 4*16 = 76  │ 152  │   3   │ 
//     32     │   1 │ 8 + 4*32 = 136 │ 136  │   2   │ 

// example: 64 bits (8 bytes)
//
//  bytes/clk │ clk │ cols           │ area │ opens │ NOTES 
// ───────────┼─────┼────────────────┼──────┼───────┼───────────────────────────────────
//      2     │   4 │ 8 + 4*2 = 16   │  64  │   5   │ 
//      4     │   2 │ 8 + 4*4 = 24   │  48  │   3   │ 
//      8     │   1 │ 8 + 4*8 = 40   │  40  │   2   │ 

const int BINARY_ID = 20;

subproof aggregate Binary(2**21, 2**23, 2**25) {

    const int bits = 256;
    const int bpc = 8;
    const int inputChunks = 8;
    const int enableLt = 1;
    const int enableTableLt4 = 1;
    assert(!enableLt || enableTableLt4);

    assert(bits % 8 == 0);
    assert(bits % (8 * bpc) == 0);

    const int bytes = bits / 8;
    assert(bytes % 2 == 0);

    const int lastbpc = bpc - 1;
    const int clocks = bits / (8 * bpc);
    const int inputChunkBytes = bytes / inputChunks;

    col witness freeInA[bpc];   // bpc x 1 Byte (input1)
    col witness freeInB[bpc];   // bpc x 1 Byte (input2)
    col witness freeInC[bpc];   // bpc x 1 Byte (output)
    col witness operation;      // operation code
    col witness carry[bpc+1];   // bpc + 1 chunks carries [cin:0,cout:1],[cin:1,cout:2],...,[cin:bpc-1,cout:bpc]
    col witness result;         // selector of result binary operation

    col witness useCarry;

    const expr cin  = carry[0];
    const expr cout = carry[bpc];

    const expr CLK0;
    if (clocks == 1) {
        CLK0 = 1;
    } else {
        col fixed _CLK0 = [1,0:(clocks-1)]...;
        CLK0 = _CLK0;
        ('operation - operation) * (1 - CLK0) === 0;
        (1 - CLK0) * 'result = 0;
        (1 - CLK0') * (cin' - cout) === 0

    }
    const expr LAST = 'CLK0;

    useCarry * (1 - useCarry) === 0;
    cout * (1 - cout) === 0;

    const expr RESET = CLK0;
    result * (1 - result) = 0;

    for (int index = 0; index < length(carry); index += 1) {
        carry[index] * (1 - carry[index]) === 0;
    }

    const expr isLt4;
    const expr reset4;
    if (enableLt4) {
        include "binary_lt4.pil"
    }

    // P_FLAGS = cOut + 2 * useCarry + 4 * usePreviousAreLt4 + 8 * reset4
    // In even byte clocks, useCarry = usePreviousAreLt4 = 0 and cOut = cMiddle, therefore P_FLAGS = cMiddle + 8 * reset4
    const expr _operation = enableLt4Table ? 100 * isLt4 + operation;

    for (int index = 0; index < (bpc - 1); ++index) {
        const expr _cin = (enableLt4 && (index % 8) == 0) ? (1 - reset4) * carry[index] : carry[index];
        lookup_assumes(BINARY_TABLE_ID, [      0, _operation, freeInA[index], freeInB[index], _cin, freeInC[index], carry[index + 1]]);
    }
    const expr _cin;
    if (enableLt4) {
        const expr previousLt4Cout;
        if (bpc == 2) { // => clocks == 16
            previousLt4Cout = 6'cout + 4'cout + 2'cout;            
        } else if (bpc == 4) { // => clocks == 8
            previousLt4Cout = 6'cout + 4'cout + 2'cout;            
        } else if (bpc == 8) { // => clocks == 4
            previousLt4Cout = 3'cout + 2'cout + 'cout;
        } else if (bpc == 16) { // => clocks == 2
            previousLt4Cout = 'carry[8] + 'cout + carry[8];
        } else if (bpc == 32) { // => clocks == 1
            previousLt4Cout = carry[8] + carry[16] + carry[24];
        }
        _cin = carry[lastbpc] + 2 * previousLt4Cout * isLt4;
    } else {
        _cin = carry[lastbpc];
    }
    lookup_assumes(BINARY_TABLE_ID, [result, _operation, freeInA[lastbpc], freeInB[lastbpc], _cin, freeInC[lastbpc], carry[bpc] + 2 * useCarry]);

    // rebuild inputChunks to create lookup

    int ichunk = 0;
    int ibyte = 0;
    expr a[inputChunks];
    expr b[inputChunks];
    expr c[inputChunks];
    for (int clk = CLOCK-1; clk >= 0; --clk) {
        for (int index = 0; index < bpc; ++index) {
            a[ichunk] = a[ichunk] + (256 ** ibyte * clk'freeInA[index]);
            b[ichunk] = b[ichunk] + (256 ** ibyte * clk'freeInB[index]);
            c[ichunk] = c[ichunk] + (256 ** ibyte * clk'freeInC[index]);
            ++ibyte;
            if (ibyte == inputChunkBytes) {
                ibyte = 0;
                ++ichunk;
            }
        }
    }

    // in logical functions like EQ, LT, SLT the result is known at end, means c[0] === 0 and c[inputChunks-1] === cout, but need to swap them
    c[0] = c[0] + useCarry * cout;
    c[inputChunks - 1] = c[inputChunks - 1] - useCarry * cout;

    multiset_proves(BINARY_ID, result,[opcode, ...a, ...b, ...c, cin, cout]);
}