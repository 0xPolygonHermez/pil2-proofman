require "std_permutation.pil"
require "std_lookup.pil"
require "tools.pil"

air Main(int N = 2**10) {
    const int NR = 8;

    /////// State Polynomials
    col witness A[NR], B[NR], C[NR], D[NR], E[NR];   // Generic Registers
    col witness SR[NR];                              // State Root
    col witness CTX;                                 // Call Cntext
    col witness SP;                                  // Stack Pointer
    col witness PC;                                  // EVM Program counter
    col witness zkPC;                                // Program Counter of current micro instruction
    col witness RR;                                  // Micro code return address (subroutines)
    col witness RCX;

    ///////  Instruction related polynomials
    col witness CONST[NR];
    col witness FREE[NR];
    col witness inA, inB, inC, inROTL_C, inD, inE, inSR, inFREE, inFREE0, inCTX, inSP, inPC, inSTEP, inRR, inRCX;
    col witness setA, setB, setC, setD, setE, setSR, setCTX, setSP, setPC, setRR, setRCX;
    col witness jmp, jmpn, jmpz, offset;
    col witness incStack;
    col witness isStack;
    col witness isMem;
    col witness ind, indRR;
    col witness useCTX;
    col witness doAssert;
    col witness condConst;
    col witness repeat, call, returnJmp;
    col witness assumeFREE;

    // operations
    col witness mOp, mWR;

    col witness isNeg;

    col witness jmpAddr;
    col witness elseAddr;
    col witness memUseAddrRel;
    col witness jmpUseAddrRel;
    col witness elseUseAddrRel;

    col fixed L1 = [1,0...];
    col fixed STEP = [0..(N-1)];
    // op registers with out of expression
    // av assumed value, could be op or FREE
    // col witness op[NR];
    const expr op[NR];
    const expr assumeInput[NR];
    const expr zeros[NR];
    for (int index = 0; index < NR; ++index) {
        expr _op =
            A[index] * inA +
            B[index] * inB +
            C[index] * inC +
            C[(index + NR - 1) % NR] * inROTL_C +
            D[index] * inD +
            E[index] * inE +
            FREE[index] * (inFREE + inFREE0) +
            SR[index] * inSR +
            CONST[index];

        if (index == 0) {
            _op +=
                CTX * inCTX +
                SP * inSP +
                PC * inPC +
                STEP * inSTEP +
                RR * inRR +
                RCX * inRCX;
        }
        zeros[index] = 0;
        op[index] = _op;
        assumeInput[index] = (1 - assumeFREE) * (op[index] - FREE[index]) + FREE[index];
    }

    /*

        ctxBase = CTX * 0x040000   ctxSize = 256K addresses * 32 bytes (256 bits) = 8MiB

        Memory Region                    Size   isMem  isStack   Content
        ctxBase + [0x000000 - 0x00FFFF]   2MiB      0        0   Context specific variables
        ctxBase + [0x010000 - 0x000000]   2MiB      0        1   EVM Stack
        ctxBase + [0x020000 - 0x03FFFF]   4MiB      1        0   EVM Memory

    */

    const expr addrRel = ind * E[0] + indRR * RR;
    const expr addr = 2**18 * useCTX * CTX +
                      2**16 * isStack + isStack*SP +
                      2**17 * isMem + memUseAddrRel * addrRel + offset;


    // op0 check zero
    col witness op0Inv;
    const expr op0IsZero = 1 - op[0]*op0Inv;
    op0IsZero * op[0] === 0;

    // TODO:
    // multiset_assumes(RANGE32_ID, jmpn, [isNeg * 2**32 + op[0], 32]);
    isNeg * (1 - isNeg) === 0;

    // RCX check zero
    col witness RCXInv;
    const expr RCXIsZero = 1 - RCX * RCXInv;
    RCXIsZero * RCX === 0;


    // Calculate New State
    for (int index = 0; index < NR; ++index) {
        A[index]' === setA * (op[index] - A[index]) + A[index];
        B[index]' === setB * (op[index] - B[index]) + B[index];
        C[index]' === setC * (op[index] - C[index]) + C[index];
        D[index]' === setD * (op[index] - D[index]) + D[index];
        E[index]' === setE * (op[index] - E[index]) + E[index];
        SR[index]' === setSR * (op[index] - SR[index]) + SR[index];
    }

    CTX' === setCTX * (op[0] - CTX) + CTX;
    SP' === setSP * (op[0] - (SP +incStack)) + (SP +incStack);
    PC' === setPC * (op[0] - PC) + PC;

    // ROM constraint: call * setRR = 0
    RR' === setRR * (op[0] - RR) + call * (zkPC + 1 - RR) + RR;

    const expr decRCX = repeat * (1 - RCXIsZero);
    RCX' === setRCX * (op[0] - (RCX-decRCX)) + (RCX-decRCX);

    const expr doJmp = jmpn * isNeg + jmp + jmpz * op0IsZero + returnJmp + call;
    const expr elseJmp = jmpn * (1-isNeg) + jmpz * (1-op0IsZero);

    // ROM/Zkasm constraint: jmpUseAddrRel * returnJmp = 0
    const expr finalJmpAddr = jmpAddr + jmpUseAddrRel * addrRel + returnJmp * (RR' - jmpAddr);
    const expr nextNoJmpZkPC = zkPC + 1 - ((1-RCXIsZero)*repeat);
    const expr finalElseAddr = elseAddr + elseUseAddrRel * elseAddr;

    // if elseAddr wasn't specified on zkasm, compiler put current address + 1
    zkPC' === doJmp * (finalJmpAddr - nextNoJmpZkPC) + elseJmp * (finalElseAddr - nextNoJmpZkPC) + nextNoJmpZkPC;

    zkPC * L1 === 0;

    // ROM lookup

    const expr romFlags;

    romFlags = compact_bin_cols([
        doAssert, mOp, mWR, isMem, isStack, useCTX, memUseAddrRel,
        jmpUseAddrRel, elseUseAddrRel, jmp, jmpn, jmpz, call, returnJmp, repeat,
        setA, setB, setC, setCTX, setD, setE,
        setPC, setRCX, setRR, setSP, setSR]);

    lookup_assumes(ROM_ID, cols: [...CONST, condConst, inA, inB, inC, inROTL_C, inD, inE, inSR, inFREE, inFREE0,
                                    inCTX, inSP, inPC, inSTEP, inRR, inRCX, ind, indRR,
                                    romFlags, offset, incStack, jmpAddr, elseAddr, zkPC]);

    // Memory
    permutation_assumes(MEMORY_ID, mOp, [addr, STEP, mWR, ...assumeInput]);
}
