require "std_permutation.pil"

const int MEMORY_ID = 4;

air Mem(int N = 2**10) {

    col fixed INCS = [1,2..N];
    col fixed LLAST = [0...,1];
    const expr IS_NOT_LAST = (1 - LLAST);
    const int MAX_STEP = 2**23;

    col witness addr;
    col witness step;
    col witness sel, wr;
    col witness value[8];
    col witness lastAccess; // 1 if its the last access of a given address

    // The list is sorted by [addr, step]
    lastAccess * (1 - lastAccess) === 0;

    // range_check(IS_NOT_LAST, lastAccess * (addr' - addr - step' + step) + step' - step, 1, MAX_STEP);


    (1 - lastAccess) * (addr' - addr) === 0;

    sel * (1 - sel) === 0;
    wr * (1 - wr) === 0;
    // wr could be 1 only if sel is 1
    (1 - sel) * wr === 0;

    // const expr isWrite = sel' * wr';
    const expr rdSame = (1 - wr) * (1-lastAccess);
    const expr rdDifferent = (1 - wr) * lastAccess;

    // lastAccess has to be 1 in the last evaluation. This is necessary to
    // validate [rdDifferent * (val[0]') = 0;] correctly (in a cyclic way)
    (lastAccess - 1) * (1 - IS_NOT_LAST) === 0;

    for (int index = 0; index < length(value); index = index + 1) {
        rdSame * (value[index]' - value[index])  ===  0;
        rdDifferent * value[index]'  ===  0;
    }

    permutation_proves(MEMORY_ID, sel, [addr, step, wr, ...value]);
}