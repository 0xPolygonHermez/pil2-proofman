require "std_sum.pil";

const string name_range_check = "range_check";
const int MAX_LEN = (PRIME - 1) / 2;
// const int OPIDS[2] = [100, 101];
// int last_assigned_opid = OPIDS[length(OPIDS) - 1];
const int OPIDS0 = 100;
const int OPIDS1 = 101;
int last_assigned_opid = OPIDS1;

// TODO: Handle opids stuff
private function next_available_opid(): int {
    last_assigned_opid = last_assigned_opid + 1;
    return last_assigned_opid;
}

const int BYTE = 2**8-1;
const int TWOBYTES = 2**16-1;

// With the logup protocol, it is more performant to look up to the same range;
// so we'll try to "absorb" all the introduced ranges into some of the default ranges.
// Moreover, having a fewer ranges makes the preprocessing faster and the prvoing less memory consuming

function range_check(int predefined, expr sel, expr colu, int min, int max) {
    range_check_def(predefined, sel, colu, min, max);
}

function range_check_nosel(int predefined, expr colu, int min, int max) {
    range_check_def(predefined, 1, colu, min, max);
}

// function range_check_group(int predefined, expr sels[], expr cols[], int min, int max) {
//     for (int i = 0; i < length(cols); i = i + 1) {
//         range_check_def(predefined, sels[i], cols[i], min, max);
//     }
// }

/**
 * TODO: Add description
 * @param predefined 1 if use the predefined range, 0 if create the specified range
 * @param sel selection vector
 * @param colu column to be range checked
 * @param min minimum value of the range
 * @param max maximum value of the range
 */
function range_check_def(int predefined, expr sel, expr colu, int min, int max) {
    if (min > max) {
        error(`min = ${min} cannot be greater than max = ${max}`);
    } else if (min == max) {
        error(`Min and max are the same, you should use a single value check instead: ${colu} == ${min}`);
    } else if (max - min + 1 < 8) { // The 8 was chosen comparing the cost of logup vs the cost of a multiple value check
        int diff = max - min + 1;

        string diff_str = `(${colu} - ${min})`;
        for (int i = 1; i < diff; i = i + 1) {
            diff_str = diff_str + `Â·(${colu} - ${min + i})`;
        }

        warn(`The range [${min}..${max}] is too small, consider using a multiple value check instead: ${diff_str} == 0`);
    } else if (max - min + 1 > MAX_LEN) {
        error(`The range [${min}..${max}] is too big, the maximum range length is (PRIME - 1) / 2 = ${MAX_LEN}`);
    } else if (max >= PRIME) {
        error(`The maximum value of the range cannot be greater than the field order ${PRIME}`);
    } else if (min <= -PRIME) {
        error(`The minimum value of the range cannot be less than the negative field order ${-PRIME}`);
    }

    if (predefined) {
        if (min == 0 && (max == BYTE || max == TWOBYTES)) {
            const int default_is_u8 = max == BYTE ? 1 : 0;

            container proof.std.rcpre alias rcpreprove {
                int u8_used = 0;
                int u16_used = 0;
            }

            int opid;
            if (default_is_u8) {
                opid = OPIDS0;
                rcpreprove.u8_used = 1;
            } else {
                opid = OPIDS1;
                rcpreprove.u16_used = 1;
            }

            sum_assumes_sel(name_range_check, opid, sel, [colu]);

            on final proof declarePreRangeSubproof()
        } else {
            // Here, we need to reuse to some of the default ranges depending
            // on the values of min and max
            if (min >= 0) {
                if (max <= BYTE) {
                    // reuse U8

                    // first prove that colu - min is in U8
                    sum_assumes_sel(name_range_check, OPIDS0, sel, [colu - min]);
                    sum_proves_nosel(name_range_check, OPIDS0, [U8]);

                    // second prove that max - colu is in U8
                    sum_assumes_sel(name_range_check, OPIDS0, sel, [max - colu]);
                    sum_proves_nosel(name_range_check, OPIDS0, [U8]);

                    // println(`Using range [${min}..${max}] for range check of ${colu} on subproof ${__SUBPROOF__}`);
                } else if (max <= TWOBYTES) {
                    // reuse U16

                    // first prove that colu - min is in U16
                    sum_assumes_sel(name_range_check, OPIDS1, sel, [colu - min]);
                    sum_proves_nosel(name_range_check, OPIDS1, [U16]);

                    // second prove that max - colu is in U16
                    sum_assumes_sel(name_range_check, OPIDS1, sel, [max - colu]);
                    sum_proves_nosel(name_range_check, OPIDS1, [U16]);
                } else {
                    // represent max and min in base TWOBYTES
                    const int nchunks_max = log2(max) / log2(TWOBYTES) + 1; // floor(log2(max) / log2(TWOBYTES)) + 1
                    const int nchunks_min = log2(min) / log2(TWOBYTES) + 1;

                    int _max = max;
                    int _min = min;
                    expr colu_repr = 0;
                    for (int i = 0; i < nchunks_max; i = i + 1) {
                        const int max_chunk = _max % TWOBYTES;
                        const int min_chunk = _min % TWOBYTES;
                        _max = _max / TWOBYTES;
                        _min = _min / TWOBYTES;

                        col witness colu_chunk;
                        colu_repr = colu_repr + colu_chunk * TWOBYTES**i;

                        @colu_chunk{reference: colu, base: TWOBYTES};

                        if (i < nchunks_min) {
                            sum_assumes_sel(name_range_check, OPIDS1, sel, [colu_chunk - min_chunk]);
                            sum_proves_nosel(name_range_check, OPIDS1, [U16]);
                        }

                        sum_assumes_sel(name_range_check, OPIDS1, sel, [max_chunk - colu_chunk]);
                        sum_proves_nosel(name_range_check, OPIDS1, [U16]);
                    }

                    // constraint asserting that the decomposition is correct
                    colu === colu_repr;
                }
            } else {
                // TO IMPLEMENT
            }
        }
    } else {
        const int opid = next_available_opid();
        sum_assumes_sel(name_range_check, opid, sel, [colu]);

        container proof.std.rc alias rcprove {
            // FIX: dynamic arrays not ready
            int opids_count = 0;
            int opids[100];

            int mins[100];
            int maxs[100];
            int max_diff = 0;
        }

        rcprove.opids[rcprove.opids_count] = opid;
        rcprove.opids_count = rcprove.opids_count + 1;
        rcprove.mins[rcprove.opids_count] = min;
        rcprove.maxs[rcprove.opids_count] = max;
        rcprove.max_diff = max - min + 1 > rcprove.max_diff ? max - min + 1 : rcprove.max_diff;

        on final proof declareRangeSubproof()
    }
}

// private function declarePreRangeSubproof() {
//     subproof PredefinedRanges(2**16) {
//         if (proof.std.rcpre.u8_used) {
//             col fixed U8 = [0..BYTE];
//             sum_proves_nosel(name_range_check, OPIDS0, [U8]);
//         }

//         if (proof.std.rcpre.u16_used) {
//             col fixed U16 = [0..TWOBYTES];
//             sum_proves_nosel(name_range_check, OPIDS1, [U16]);
//         }
//     }
// }

// private function declareRangeSubproof() {
//     use proof.std.rc;

//     const int next_pow2 = 2**(log2(max_diff) + 1); // 2**ceil(log2(max_diff)) + 1

//     subproof SpecifiedRanges(next_pow2) {
//         for (int index = 0; index < opids_count; index = index + 1) {
//             int opid = opids[index];
//             int min = mins[index];
//             int max = maxs[index];

//             col fixed RANGE = [min..max];
//             sum_proves_nosel(name_range_check, opid, [RANGE]);
//         }
//     }
// }
