require "std_sum.pil";
require "std_permutation.pil";
// require "std_chunk_checker.pil";

// With the logup protocol, it is more performant to look up to the same range;
// so we'll try to "absorb" all the introduced ranges into some of the default ranges.
// Moreover, having a fewer ranges makes the preprocessing faster and the prvoing less memory consuming

const string name_range_check = "range_check";
const int MAX_LEN = (PRIME - 1) / 2;

const int OPIDS[2] = [100, 101];
int last_assigned_opid = OPIDS[length(OPIDS) - 1];

private function next_available_opid(): int {
    last_assigned_opid++;
    return last_assigned_opid;
}

const int BYTE = 2**8-1;
const int TWOBYTES = 2**16-1;

airtemplate U8Air(const int N = 2**8) {
    if (N != 2**8) {
        error(`The number of rows N should be 2**8 to use the predefined range U8, got N=${N} instead`);
    }

    col witness mul;
    col fixed U8 = [0..BYTE];
    sum_proves(name_range_check, OPIDS[0], mul, [U8]);
}

airtemplate U16Air(const int N = 2**16) {
    if (N != 2**16) {
        error(`The number of rows N should be 2**16 to use the predefined range U16, got N=${N} instead`);
    }

    col witness mul;
    col fixed U16 = [0..TWOBYTES];
    sum_proves(name_range_check, OPIDS[1], mul, [U16]);
}

airtemplate SpecifiedRanges(const int N, const int opids[], const int opids_count, const int mins[], const int maxs[]) {
    col witness mul[opids_count];

    for (int j = 0; j < opids_count; j++) {
        int opid = opids[j];
        int min = mins[j];
        int max = maxs[j];

        if (N < max - min + 1) {
            error(`The range [min,max]=[${min},${max}] is too big, the maximum range length is ${N}`);
        }

        col fixed RANGE = [min..max-1,max...];
        sum_proves(name_range_check, opid, mul[j], [RANGE]);
    }
}

function range_check_group(const int predefined = 1, const expr sels[], const expr cols[], const int min, const int max) {
    for (int i = 0; i < length(cols); i = i + 1) {
        range_check(predefined, sels[i], cols[i], min, max);
    }
}

/**
 * TODO: Add description
 * @param predefined 1 if use the predefined range, 0 if create the specified range
 * @param sel selection vector
 * @param colu column to be range checked
 * @param min minimum value of the range
 * @param max maximum value of the range
 */
function range_check(const int predefined = 1, const expr sel = 1, const expr colu, const int min, const int max) {
    @range_check{predefined:predefined, colu: colu, min: min, max: max};

    if (min > max) {
        error(`min = ${min} cannot be greater than max = ${max}`);
    } else if (min == max) {
        error(`Min and max are the same, you should use a single value check instead: ${colu} == ${min}`);
    } else if (max - min + 1 < 8) { // The 8 was chosen comparing the cost of logup vs the cost of a multiple value check
        const int diff = max - min + 1;

        string diff_str = `(${colu} - ${min})`;
        for (int i = 1; i < diff; i = i + 1) {
            diff_str = diff_str + `·(${colu} - ${min + i})`;
        }

        println(`The range [${min}..${max}] is too small, consider using a multiple value check instead: ${diff_str} == 0`);
    } else if (max - min + 1 > MAX_LEN) {
        error(`The range [${min}..${max}] is too big, the maximum range length is (PRIME - 1) / 2 = ${MAX_LEN}`);
    } else if (max >= PRIME) {
        error(`The maximum value of the range cannot be greater than the field order ${PRIME}`);
    } else if (min <= -PRIME) {
        error(`The minimum value of the range cannot be less than the negative field order ${-PRIME}`);
    }

    if (min < 0) {
        println(`The provided min=${min} is negative. Falling back to specified range...`);
    } else if (max > TWOBYTES) {
        println(`The provided max=${max} is greater than the maximum predefined ${TWOBYTES}. Falling back to specified range...`);
    }

    if (predefined && min >= 0 && max <= TWOBYTES) {
        container proof.std.rcpre alias rcpreprove {
            int max_airgroup_id = 0;
            int u8_used = 0;
            int u16_used = 0;
        }

        if (rcpreprove.max_airgroup_id < AIRGROUP_ID) {
            rcpreprove.max_airgroup_id = AIRGROUP_ID;
        }

        if (min == 0 && (max == BYTE || max == TWOBYTES)) {
            const int is_u8 = max == BYTE ? 1 : 0;

            rcpreprove.u8_used = rcpreprove.u8_used ? 1 : is_u8;
            rcpreprove.u16_used = rcpreprove.u16_used ? 1 : (1 - is_u8);

            sum_assumes(name_range_check, is_u8 ? OPIDS[0] : OPIDS[1], sel, [colu]);
        } else {
            // Here, we need to reuse to some of the default ranges depending
            // on the values of min and max
            if (max <= BYTE) {
                // reuse U8
                rcpreprove.u8_used = 1;

                // first prove that colu - min is in U8
                sum_assumes(name_range_check, OPIDS[0], sel, [colu - min]);

                // then prove that max - colu is in U8
                sum_assumes(name_range_check, OPIDS[0], sel, [max - colu]);
            } else if (max <= TWOBYTES) {
                // reuse U16
                rcpreprove.u16_used = 1;

                // first prove that colu - min is in U16
                sum_assumes(name_range_check, OPIDS[1], sel, [colu - min]);

                // second prove that max - colu is in U16
                sum_assumes(name_range_check, OPIDS[1], sel, [max - colu]);

            // TODO: This is for the big case, to be decided!
            // } else {
            //     error("Not implemented yet");

            //     // reuse U16
            //     rcpreprove.u16_used = 1;

            //     // represent max and min in base TWOBYTES
            //     // min = m₀ + 2¹⁶·m₁ + (2¹⁶)²·m₂ + ... + (2¹⁶)ⁿ¹·mₙ
            //     // val = v₀ + 2¹⁶·v₁ + (2¹⁶)²·v₂ + ... + (2¹⁶)ⁿ²·vₙ
            //     // max = M₀ + 2¹⁶·M₁ + (2¹⁶)²·M₂ + ... + (2¹⁶)ⁿ³·Mₙ
            //     // where n = nchunks_max

            //     // We have to check that either (2¹⁶ > vₙ - mₙ > 0) or (vₙ - mₙ = 0 and 2¹⁶ > vₙ₋₁ - mₙ₋₁ > 0) or ...
            //     // and also that either (2¹⁶ > Mₙ - vₙ > 0) or (Mₙ - vₙ = 0 and 2¹⁶ > Mₙ₋₁ - vₙ₋₁ > 0) or ...
            //     // We'll need auxiliar columns to encode this two big OR in terms of constraints
            //     // ChunkChecker(N*nchunks_max, min, max);

            //     // Moreover, we should check the decomposition is correct
            //     permutation_assumes(CHUNK_CHECKER_ID, cols: [colu]);
            // }

            // TODO: This is for the negative case, to be decided!
            // } else {
            //     error("Not implemented yet");

            //     // Path where min < 0 and max > 0
            //     // We split the range [min,max] into two ranges [min,0] and [0,max]
            //     // and we prove that either val is in the first range or the second one
            //     // choosing it based on a new selector
            //     // These are four range checks in total, two for each range (either to U8 or U16 based on the values of min max)

            //     // col witness rangeSel;

            //     // // first prove that colu - min is in U16
            //     // sum_assumes(name_range_check, OPIDS[1], rangeSel*sel, [colu - (PRIME + min)]);

            //     // // second prove that max - colu is in U16
            //     // sum_assumes(name_range_check, OPIDS[1], rangeSel*sel, [- colu]);
            }
        }

        on final airgroup declarePreRangeAir();
    } else {
        container proof.std.rc alias rcprove {
            int max_airgroup_id = 0;
            int opids_count = 0;
            int max_diff = 0;

            // FIX: dynamic arrays not ready
            int opids[100];
            int mins[100];
            int maxs[100];
        }

        if (rcprove.max_airgroup_id < AIRGROUP_ID) {
            rcprove.max_airgroup_id = AIRGROUP_ID;
        }

        on final airgroup declareRangeAir();

        // If the range has already been introduced, we reuse the same opid
        for (int i = 0; i < rcprove.opids_count; i++) {
            if (min == rcprove.mins[i] && max == rcprove.maxs[i]) {
                sum_assumes(name_range_check, rcprove.opids[i], sel, [colu]);
                return;
            }
        }

        int opid = 0;
        if (min == 0 && max == BYTE) {
            opid = OPIDS[0];
        } else if (min == 0 && max == TWOBYTES) {
            opid = OPIDS[1];
        } else {
            opid = next_available_opid();
        }

        sum_assumes(name_range_check, opid, sel, [colu]);

        rcprove.mins[rcprove.opids_count] = min;
        rcprove.maxs[rcprove.opids_count] = max;
        rcprove.opids[rcprove.opids_count] = opid;
        rcprove.opids_count++;
        rcprove.max_diff = max - min > rcprove.max_diff ? max - min : rcprove.max_diff;
    }
}

private function declarePreRangeAir() {
    use proof.std.rcpre;

    if (AIRGROUP_ID != max_airgroup_id) {
        return;
    }

    if (u8_used) {
        airgroup U8Air {
            U8Air();
        }
    }

    if (u16_used) {
        airgroup U16Air {
            U16Air();
        }
    }
}

private function declareRangeAir() {
    use proof.std.rc;

    if (AIRGROUP_ID != max_airgroup_id) {
        return;
    }

    const int next_pow2 = 2**(log2(max_diff));

    _SpecifiedRanges( // TODO: Remove this function
                    next_pow2,
                    opids,
                    opids_count,
                    mins,
                    maxs
                );
}

function _SpecifiedRanges(int a,int b[],int c,int d[],int e[]) {
    airgroup SpecifiedRanges {
        SpecifiedRanges(a,b,c,d,e);
    }
}
