require "std_common.pil"
require "std_sum.pil"

const string name_range_check = "range_check";
const int MAX_LEN = (PRIME - 1) / 2;

// With the logup protocol, it is more performant to look up to the same range;
// so we'll try to "absorb" all the introduced ranges into some of the default ranges.
// Moreover, having a fewer ranges makes the preprocessing faster and the prvoing less memory consuming

function range_check(int specific, expr sel, expr colu, int min, int max) {
    range_check_def(specific, sel, colu, min, max);
}

function range_check_nosel(int specific, expr colu, int min, int max) {
    range_check_def(specific, 1, colu, min, max);
}

// function range_check_group(int specific, expr sels[], expr cols[], int min, int max) {
//     for (int i = 0; i < length(cols); i = i + 1) {
//         range_check_def(specific, sels[i], cols[i], min, max);
//     }
// }

/**
 * TODO: Add description
 * @param specific 1 if use the default range, 0 if create the specified range
 * @param sel selection vector
 * @param colu column to be range checked
 * @param min minimum value of the range
 * @param max maximum value of the range
 */
function range_check_def(int specific, expr sel, expr colu, int min, int max) {
    if (min > max) {
        error(`min = ${min} cannot be greater than max = ${max}`);
    } else if (min == max) {
        error(`Min and max are the same, you should use a single value check instead: ${colu} == ${min}`);
    } else if (max - min < 8) { // The 8 was chosen comparing the cost of logup vs the cost of a multiple value check
        int diff = max - min;

        string diff_str = `(colu - ${min})`;
        for (int i = 1; i < diff; i = i + 1) {
            diff_str = diff_str + `Â·(colu - ${min + i})`;
        }

        warn(`The range [${min}..${max}] is too small, consider using a multiple value check instead: ${diff_str} == 0`);
    } else if (max - min > MAX_LEN) {
        error(`The range [${min}..${max}] is too big, the maximum range length is ${MAX_LEN}`);
    } else if (max >= PRIME) {
        error(`The maximum value of the range cannot be greater than the field order ${PRIME}`);
    } else if (min <= -PRIME) {
        error(`The minimum value of the range cannot be less than the negative field order ${-PRIME}`);
    }

    if (specific) {
        // TODO: Add in a subproof????
        // Default ranges
        const int byte = 2**8-1;
        const int twobytes = 2**16-1;
        col fixed U8 = [0,1..+..byte];
        col fixed U16 = [0,1..+..twobytes];

        if (min == 0 && (max == byte || max == twobytes)) {
            int default_range = max == byte ? 1 : 0;

            // assume with predefined opid
            sum_assumes_sel(name_range_check, default_range ? 100 : 101, sel, [colu]);

            // prove
            sum_proves_nosel(name_range_check, default_range ? 100 : 101, default_range ? U8 : U16);
        } else {
            // Here, we need to reuse to some of the default ranges depending
            // on the values of min and max
            if (min >= 0) {
                if (max <= byte) {
                    // reuse U8

                    // first prove that colu - min is in U8
                    sum_assumes_sel(name_range_check, 100, sel, [colu - min]);
                    sum_proves_nosel(name_range_check, 100, [U8]);

                    // second prove that max - colu is in U8
                    sum_assumes_sel(name_range_check, 100, sel, [max - colu]);
                    sum_proves_nosel(name_range_check, 100, [U8]);
                } else if (max <= twobytes) {
                    // reuse U16

                    // first prove that colu - min is in U16
                    sum_assumes_sel(name_range_check, 101, sel, [colu - min]);
                    sum_proves_nosel(name_range_check, 101, [U16]);

                    // second prove that max - colu is in U16
                    sum_assumes_sel(name_range_check, 101, sel, [max - colu]);
                    sum_proves_nosel(name_range_check, 101, [U16]);
                } else {
                    // represent max and min in base twobytes
                    const int nchunks_max = log2(max) / log2(twobytes) + 1; // ceil(log2(max) / log2(twobytes)) + 1
                    const int nchunks_min = log2(min) / log2(twobytes) + 1;

                    int _max = max;
                    int _min = min;
                    expr colu_repr = 0;
                    for (int i = 0; i < nchunks_max; i = i + 1) {
                        const int max_chunk = _max % twobytes;
                        const int min_chunk = _min % twobytes;
                        _max = _max / twobytes;
                        _min = _min / twobytes;

                        col witness colu_chunk;
                        colu_repr = colu_repr + colu_chunk * twobytes**i;

                        @colu_chunk{reference: colu, base: twobytes};

                        if (i < nchunks_min) {
                            sum_assumes_sel(name_range_check, 101, sel, [colu_chunk - min_chunk]);
                            sum_proves_nosel(name_range_check, 101, [U16]);
                        }

                        sum_assumes_sel(name_range_check, 101, sel, [max_chunk - colu_chunk]);
                        sum_proves_nosel(name_range_check, 101, [U16]);
                    }

                    // constraint asserting that the decomposition is correct
                    colu === colu_repr;
                }
            } else {
                // TO IMPLEMENT
            }
        }
    } else {
        sum_assumes_sel(name_range_check, next_opid_mock(), sel, [colu]);

        // col fixed RANGE = [min,min+1..+..max]...;
        col fixed RANGE = [min,min+1..+..max];

        sum_proves_nosel(name_range_check, next_opid_mock(), [RANGE]);
    }
}
