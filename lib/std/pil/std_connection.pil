require "std_constants.pil";
require "std_prod.pil";

// In order to prove correctness of a connection, we should compute the product:
//     (f_0+𝛂·ID_0+ɣ)  · (f_1+𝛂·ID_1+ɣ)  ·...·(f_N+𝛂·ID_N+ɣ)
//    ---------------------------------------------------------------------------------
//     (f_0+𝛂·PER_0+ɣ) · (f_1+𝛂·PER_1+ɣ) ·...·(f_N+𝛂·PER_N+ɣ)
// where ID_0(X) := X and ID_i(X) := k_i·X for i > 0
// and PER_i(X) describe a permutation of the group_domain
// as described in the PlonK paper https://eprint.iacr.org/2019/953.pdf

const string name_connection = "connection";

private function init_coset_constants(int len): int[] {
    // Code from https://github.com/0xPolygonHermez/pilcom/blob/develop/src/utils.js#L8

    int std_ks[len]; // This is the array of constants that generate distinct cosets of the group_domain
                           // Check https://eprint.iacr.org/2019/953.pdf for further details

    std_ks[0] = k;
    for (int i = 1; i < len; i = i + 1) {
        std_ks[i] = std_ks[i-1] * std_ks[0];
    }

    return std_ks;
}

// Two user interfaces

// 1] Interface where the user uses either the update_one_cell() or the update_multiple_cells() method to define the permutation "on the fly"
//    and when it is done, executes the connect() method to perform the connection argument.
//    The user also needs to execute init() at the beginning.

function connection_init(int opid, expr cols[]) {
    const int cols_count = length(cols);

    if (cols_count < 1) {
        error(`The number of columns of connect #${opid} must be at least 1`);
    }

    container air.std.connect alias conn {
        int opids_count = 0;
        int opids[100];

        // int std_ks[cols_count] = init_coset_constants(cols_count);
        int std_ks[cols_count];
        col fixed group_domain = [1,GEN[BITS]..*..]; // {1,𝛚,𝛚²,...,𝛚ᴺ⁻¹}
    }

    container air.std.connect.`id${opid}` alias connid {
        int closed;
        int cols_num = 0;
        expr map_cols[cols_count];
        expr PERs[cols_count];
    }

    if (connid.cols_num == 0) {
        // Properties of each connection in the air
        connid.closed = 0;
        connid.cols_num = cols_count;

        // Properties of every connection in the air
        conn.opids[conn.opids_count] = opid;
        conn.opids_count = conn.opids_count + 1;
    } else {
        error(`Init of connect #${opid} has already been called`);
    }

    for (int i = 0; i < cols_count; i = i + 1) {
        // Create a mapping of indexes to set a specific order of the columns the first time it is called
        connid.map_cols[i] = cols[i];

        // Initialize polynomial PER_0(X) as X and PER_i(X) as k_i·X, for i >= 0
        if (i == 0) {
            std_ks[0] = k;

            for (int j = 0; j < N; j = j + 1) {
                connid.PERs[0][j] = group_domain[j];
            }
        } else {
            std_ks[i] = std_ks[i-1] * std_ks[0];

            for (int j = 0; j < N; j = j + 1) {
                connid.PERs[i][j] = std_ks[i-1] * group_domain[j];
            }
        }
    }

    // At the end of the air, check if the initialized connections were ever closed
    on final air checkClosed()
}

/**
 * It connects the cell of a column with a different cell of any other column (including itself)
 * @param opid (unique) identifier of the connection
 * @param cols1 columns of the cells to be swapped
 * @param rows1 rows of the cells to be swapped
 * @param cols2 columns of the cells to be swapped
 * @param rows2 rows of the cells to be swapped
 * @param frame_size frame at which the cells are swapped and gets repeated until the end
 */
function connection_update_one_cell(int opid, expr cols1[], int rows1[], expr cols2[], int rows2[], int frame_size) {
    use air.std.connect.`id${opid}`;

    const int len = length(cols1);

    if (!(len == length(rows1) == length(cols2) == length(rows2))) {
        error(`The number of columns and rows of connect #${opid} must be the same`);
    } else if (len < 1) {
        error(`The number of updated columns of connect #${opid} must be at least 1`);
    } else if (len > cols_num) {
        error(`The number of updated columns of connect #${opid} must be at most ${cols_num}`);
    }

    const int frame_number = N / frame_size;

    // Swap the cells for each frame
    for (int i = 0; i < len; i = i + 1) {
        const int col1_index = find_col_index(opid, cols1[i]);
        const int col2_index = find_col_index(opid, cols2[i]);

        const int row1 = rows1[i];
        const int row2 = rows2[i];

        if (row1 < 0 || row1 >= frame_size) {
            error(`The row ${row1} of column ${cols1[i]} is out of bounds`);
        } else if (row2 < 0 || row2 >= frame_size) {
            error(`The row ${row2} of column ${cols2[i]} is out of bounds`);
        }

        if (col1_index == col2_index && row1 == row2) {
            warn(`You are connecting the same cell ${cols1[i]}[${row1], consider removing it. Skipping...`);
            continue;
        }

        for (int f = 0; f < frame_number; f = f + 1)  {
            const int row1_ref = rows1[i + f*frame_size];
            const int row2_ref = rows2[i + f*frame_size];

            const int tmp = PERs[col1_index][row1_ref];
            PERs[col1_index][row1_ref] = PERs[col2_index][row2_ref];
            PERs[col2_index][row2_ref] = tmp;
        }
    }
}

/**
 * It connects the cells of multiple columns
 * Check https://youtu.be/Crzw7ccuHd0?t=1276&si=M8sVdwvKhmIZQnJZ for a pictorial representation
 * @param opid (unique) identifier of the connection
 * @param cols columns of the cells to be swapped
 * @param rows_arrays array of rows of the cells to be swapped
 * @param frame_size frame at which the cells are swapped and gets repeated until the end
 */
function connection_update_multiple_cells(int opid, expr cols[], int rows_arrays[][], int frame_size) {
    use air.std.connect.`id${opid}`;

    const int len = length(cols);

    if (len != length(rows_arrays)) {
        error(`The number of columns and rows of connect #${opid} must be the same`);
    } else if (len < 1) {
        error(`The number of updated columns of connect #${opid} must be at least 1`);
    } else if (len > cols_count) {
        error(`The number of updated columns of connect #${opid} must be at most ${cols_count}`);
    }

    // We need to first sort the columns based on its committed order in init()
    for (int i = 1; i < len; i = i + 1) { // O(n²) algorithm
        const expr coli = cols[i];
        const int col_indexi = find_col_index(opid, coli);
        const int len_row_array = length(rows_arrays[i]);
        const int row_array[len_row_array] = rows_arrays[i];

        int j = i - 1;
        for (j; j >= 0; j = j - 1) {
            const int col_indexj = find_col_index(opid, cols[j]);
            if (col_indexj > col_indexi) {
                cols[j+1] = cols[j];
                rows_arrays[j+1] = rows_arrays[j];
            }
        }
        cols[j+1] = coli;
        rows_arrays[j+1] = row_array;
    }

    // We need to find the last element of the last column
    // Get the row_array associated with the last column
    const int last_row_array = rows_arrays[len-1];
    int lra_max = last_row_array[0];
    for (int i = 0; i < length(last_row_array); i = i + 1) {
        lra_max = last_row_array[i] > lra_max ? last_row_array[i] : lra_max;
    }

    // Get its associated element
    int last_element[len];
    last_element[len-1] = PERs[find_col_index(opid, cols[len-1])][lra_max];

    const int frame_number = N / frame_size;

    // Swap the cells for each frame
    for (int i = 0; i < len; i = i + 1) {
        const expr coli = cols[i];
        const int col_index = find_col_index(opid, coli);
        const int row_len = length(rows_arrays[i]);
        const int row_array[row_len] = rows_arrays[i];

        // Sort the row_array
        for (int j = 1; j < row_len; j = j + 1) {
            const int row = row_array[j];
            int k = j - 1;
            for (k; k >= 0; k = k - 1) {
                if (row_array[k] > row) {
                    row_array[k+1] = row_array[k];
                }
            }
            row_array[k+1] = row;
        }

        const expr PER = PERs[col_index];
        last_element[i] = PER[row_array[row_len-1]];

        if (row_len > 1) {
            for (int j = row_len - 2; j >= 0; j = j - 1) {
                const int row1 = row_array[j];
                const int row2 = row_array[j+1];

                PER[row2] = PER[row1]
            }
        }

        // PER[row_array[0]] = last_element[i-1];
        PER[row_array[0]] = i == 0 ? last_element[len-1] : last_element[i-1];

        // Reassign the PER to the column
        PERs[col_index] = PER;
    }
}

function connection_connect(int opid) {
    use air.std.connect.`id${opid}`;

    col fixed PER[cols_num];
    PER[0] = PERs[0];
    // send to the bus the first column
    prod_assumes_nosel(name_connection, opid, [map_cols[0], group_domain]);
    prod_proves_nosel(name_connection, opid, [map_cols[0], PER[0]]);

    if (cols_num > 1) {
        // Compute the fixed columns generated by the connection and send to the bus
        col fixed IDs[cols_num - 1];
        for (int i = 0; i < cols_num - 1; i = i + 1) {
            for (int j = 0; j < N; j = j + 1) {
                IDs[i][j] = std_ks[i] * group_domain[j];
            }
            PER[i+1] = PERs[i+1];
            prod_assumes_nosel(name_connection, opid, [map_cols[i+1], IDs[i]]);
            prod_proves_nosel(name_connection, opid, [map_cols[i+1], PER[i+1]]);
        }
    }

    // Mark the connection as closed
    connid.closed = 1;
}

private function find_col_index(int opid, expr column): int {
    use air.std.connect.`id${opid}`;

    for (int i = 0; i < cols_num; i = i + 1) {
        if (map_cols[i] == column) {
            return i;
        }
    }

    error(`Column ${column} has not been found in connect #${opid}`);
}

private function checkClosed() {
    for (int i = 0; i < air.std.connect.opids_count; i = i + 1) {
        const int opid = air.std.connect.opids[i];
        use air.std.connect.`id${opid}`;
        if (closed == 0) {
            error(`Connection #${opid} was never closed`);
        }
    }
}

// 2] Interface where the user knows both the inputs (placed in assumes) and the
//    permutation (placed in proves) of the argument.
function connection(int opid, expr cols[], expr maps[]) {
    const int len = length(cols);

    // int std_ks[len] = init_coset_constants(len);
    int std_ks[len];
    std_ks[0] = k;
    const int G = GEN[BITS];
    col fixed group_domain = [1,G..*..]; // {1,𝛚,𝛚²,...,𝛚ᴺ⁻¹}

    // send to the bus the first column
    prod_assumes_nosel(name_connection, opid, [cols[0], group_domain]);
    prod_proves_nosel(name_connection, opid, [cols[0], maps[0]]);

    if (len == 1) return;

    col fixed domain_shifted[len - 1];
    for (int i = 1; i < len; i = i + 1) {
        std_ks[i] = std_ks[i-1] * std_ks[0];

        for (int j = 0; j < N; j = j + 1) {
            domain_shifted[i-1][j] = std_ks[i-1] * group_domain[j];
        }
        prod_assumes_nosel(name_connection, opid, [cols[i], domain_shifted[i-1]]);
        prod_proves_nosel(name_connection, opid, [cols[i], maps[i]]);
    }
}
