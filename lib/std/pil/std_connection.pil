require "std_constants.pil";
require "std_prod.pil";

// In order to prove correctness of a connection, we should compute the product:
//     (f_0+𝛂·ID_0+ɣ)  · (f_1+𝛂·ID_1+ɣ)  ·...·(f_N+𝛂·ID_N+ɣ)
//    ---------------------------------------------------------------------------------
//     (f_0+𝛂·PER_0+ɣ) · (f_1+𝛂·PER_1+ɣ) ·...·(f_N+𝛂·PER_N+ɣ)
// where ID_0(X) := X and ID_i(X) := k_i·X for i > 0
// and PER_i(X) describe a permutation of the group_domain
// as described in the PlonK paper https://eprint.iacr.org/2019/953.pdf

const string name_connection = "connection";

// Two user interfaces

// 1] Interface where the user uses either the update_one_cell() or the update_multiple_cells() method to define the permutation "on the fly"
//    and when it is done, executes the connect() method to perform the connection argument.
//    The user also needs to execute init() at the beginning.

// TODO: Add predefined frame_size in init()

function connection_init(int opid, expr cols[]) {
    const int cols_count = length(cols);

    if (cols_count < 1) {
        error(`The number of columns of connect #${opid} must be at least 1`);
    }

    container air.std.connect alias conn {
        int opids_count = 0;
        int opids[100];

        // It would be awesome to define the following data at the proof level
        // So they can be reused by every air with the same size N
        col fixed group_domain = [1,GEN[BITS]..*..]; // {1,𝛚,𝛚²,...,𝛚ᴺ⁻¹}
        expr IDs[100];
        int ks[100];
        int ids_count = 0;
    }

    container air.std.connect.`id${opid}` alias connid {
        int closed;
        int cols_num = 0;

        expr map_cols[cols_count];
        col fixed PERs[cols_count];

        // 1st dimension: in the worst case, every cell is connected pairwise with another cell
        // 2nd dimension: 0: connection identifier, 1: column index 1, 2: row index 1, 3: column index 2, 4: row index 2
        int conn_indicator[cols_count*N/2][5];
        int conn_index = 0;
        int counter = 0;
    }

    if (connid.cols_num == 0) {
        // Properties of each connection in the air
        connid.closed = 0;
        connid.cols_num = cols_count;

        // Properties of every connection in the air
        conn.opids[conn.opids_count] = opid;
        conn.opids_count = conn.opids_count + 1;
    } else {
        error(`Init of connect #${opid} has already been called`);
    }

    // Compute the IDs and ks if necessary, otherwise reuse the already computed
    if (connid.cols_num > conn.ids_count) {
        if (conn.ids_count == 0) {
            conn.IDs[0] = conn.group_domain;
            conn.ks[0] = 1;
            conn.ids_count = 1;
        }

        for (int i = conn.ids_count; i < connid.cols_num; i = i + 1) {
            // Check https://eprint.iacr.org/2019/953.pdf for details on why we need such Goldilocks_k
            conn.ks[i] = Goldilocks_k ** i;

            // Assign to reuse in the future
            conn.IDs[i] = conn.ks[i] * conn.group_domain;
        }

        // update the already computed IDs
        conn.ids_count = connid.cols_num;
    }

    for (int i = 0; i < cols_count; i = i + 1) {
        // Create a mapping of indexes to set a specific order of the columns the first time it is called
        connid.map_cols[i] = cols[i];

        // Initialize polynomial PER_0(X) as X and PER_i(X) as k_i·X, for i >= 0
        for (int j = 0; j < N; j = j + 1) {
            connid.PERs[i][j] = conn.ks[i] * conn.group_domain[j];
        }
    }

    // At the end of the air, check if the initialized connections were ever closed
    on final air checkClosed();
}

/**
 * It connects the cell of a column with a different cell of any other column (including itself). It can be used in batch.
 *
 * @param {int} opid - The (unique) identifier of the connection
 * @param {expr[][]} conn - Array of columns and rows of the cells to be swapped
 * @param {int} frame_size - Frame at which the cells are swapped and gets repeated until the end
 * @example
 * col witness a,b;
 * connection_init(opid, [a, b]);
 * connection_update_one_cell(opid, [a,1,b,2])
 * connection_update_one_cell(opid, [[b,3,c,0],[a,1,c,0]], N/2)
 */
function connection_update_one_cell(int opid, expr conn[], int frame_size) {
    if (!defined(air.std.connect.`id${opid}`)) {
        error(`Connect #${opid} has not been initialized`);
    }

    if (frame_size < 1) {
        error(`The frame size of connect #${opid} must be at least 1`);
    } else if (frame_size > N) {
        error(`The frame size of connect #${opid} must be at most ${N}`);
    }

    use air.std.connect.`id${opid}`;

    const int len = length(conn);
    if (len == 0) {
        error(`Connection #${opid} cannot be empty`);
    } else if (len % 4 != 0) {
        error(`Connection #${opid} is not well defined`);
    }

    const int frame_number = N / frame_size;

    for (int i = 0; i < len; i = i + 4) {
        const int col1_index = find_col_index(opid, conn[i]);
        const int row1_index = conn[i+1];

        const int col2_index = find_col_index(opid, conn[i+2]);
        const int row2_index = conn[i+3];

        if (row1_index < 0 || row1_index >= frame_size) {
            error(`The row ${row1_index} of column ${conn[i]} is out of bounds`);
        } else if (row2_index < 0 || row2_index >= frame_size) {
            error(`The row ${row2_index} of column ${conn[i+2]} is out of bounds`);
        }

        if (col1_index == col2_index && row1_index == row2_index) {
            println(`You are connecting the row ${row1_index} of ${conn[i]} to itself, consider removing it. Skipping...`); // Fix: Add a warn instead
            continue;
        }

        // Define the connection for each frame
        for (int f = 0; f < frame_number; f = f + 1)  {
            define_connection(opid, col1_index, row1_index + f*frame_size, col2_index, row2_index + f*frame_size);
        }
    }
}

/**
 * It connects multiple cells at once.
 *
 * Check https://youtu.be/Crzw7ccuHd0?t=1276&si=M8sVdwvKhmIZQnJZ for a pictorial representation
 *
 * @param {int} opid - The (unique) identifier of the connection
 * @param {expr[]} conn - Array of columns and rows of the cells to be swapped
 * @param {int} frame_size - Frame at which the cells are swapped and gets repeated until the end
 * @example
 * col witness a,b;
 * connection_init(opid, [a, b, c, d]);
 * connection_update_multiple_cells(opid, [d,2,d,3,b,0]);
 * connection_update_multiple_cells(opid, [c,10,b,3,a,65,c,9,c,8], N/2);
 */
function connection_update_multiple_cells(int opid, expr conn[], int frame_size) {
    if (!defined(air.std.connect.`id${opid}`)) {
        error(`Connect #${opid} has not been initialized`);
    }

    if (frame_size < 1) {
        error(`The frame size of connect #${opid} must be at least 1`);
    } else if (frame_size > N) {
        error(`The frame size of connect #${opid} must be at most ${N}`);
    }

    use air.std.connect.`id${opid}`;

    const int len = length(conn);
    if (len == 0) {
        error(`Connection #${opid} cannot be empty`);
    } else if (len == 2) {
        error(`Connection #${opid} must connect at least two cells`);
    } else if (len % 2 != 0) {
        error(`Connection #${opid} is not well defined`);
    }

    const int frame_number = N / frame_size;

    for (int i = 0; i < len - 2; i = i + 2) {
        const int col1_index = find_col_index(opid, conn[i]);
        const int row1_index = conn[i+1];

        const int col2_index = find_col_index(opid, conn[i+2]);
        const int row2_index = conn[i+3];

        if (row1_index < 0 || row1_index >= frame_size) {
            error(`The row ${row1_index} of column ${conn[i]} is out of bounds`);
        } else if (row2_index < 0 || row2_index >= frame_size) {
            error(`The row ${row2_index} of column ${conn[i+2]} is out of bounds`);
        }

        if (col1_index == col2_index && row1_index == row2_index) {
            println(`You are connecting the row ${row1_index} of ${conn[i]} to itself, consider removing it. Skipping...`); // Fix: Add a warn instead
            continue;
        }

        // Define the connection for each frame
        for (int f = 0; f < frame_number; f = f + 1)  {
            define_connection(opid, col1_index, row1_index + f*frame_size, col2_index, row2_index + f*frame_size);
        }
    }
}

private function define_connection(int opid, int col1_index, int row1_index, int col2_index, int row2_index) {
    use air.std.connect.`id${opid}`;

    int alreay_connected = 0;
    for (int i = 0; i < counter; i = i + 1) {
        // const int conn = conn_indicator[i]; // Fix: No implemented yet
        const int cond1 = col1_index == conn_indicator[i][1] && row1_index == conn_indicator[i][2];
        const int cond2 = col2_index == conn_indicator[i][3] && row2_index == conn_indicator[i][4];
        const int cond3 = col1_index == conn_indicator[i][3] && row1_index == conn_indicator[i][4] && col2_index == conn_indicator[i][1] && row2_index == conn_indicator[i][2];

        if ((cond1 && cond2) || cond3) {
            // Connection already defined, mapping structure does not change
            return;
        } else if (cond1 || cond2) {
            // Connecting with an already connected cell, use the same connection
            conn_indicator[counter][0] = conn_indicator[i][0];
            alreay_connected = 1;
            break;
        }
    }

    if (!alreay_connected) {
        conn_indicator[counter][0] = conn_index;
        conn_index = conn_index + 1;
    }

    // Store the connection
    // conn_indicator[counter] = [counter, col1_index, row1_index, col2_index, row2_index]; // TODO: No implemented yet
    conn_indicator[counter][1] = col1_index;
    conn_indicator[counter][2] = row1_index;
    conn_indicator[counter][3] = col2_index;
    conn_indicator[counter][4] = row2_index;

    counter = counter + 1;
}

function connection_connect(int opid) {
    if (!defined(air.std.connect.`id${opid}`)) {
        error(`Connect #${opid} has not been initialized`);
    }

    use air.std.connect.`id${opid}`;

    // Compute the permutation of connected cells
    for (int i = 0; i < counter; i = i + 1) {
        // const int conni[5] = conn_indicator[i]; // Fix: No implemented yet
        const int conn_id = conn_indicator[i][0];
        const int col1_id = conn_indicator[i][1];
        const int row1_id = conn_indicator[i][2];
        const int col2_id = conn_indicator[i][3];
        const int row2_id = conn_indicator[i][4];

        // Find all connections with the same identifier
        int conn_cluster[N*cols_num][2];
        conn_cluster[0][0] = col1_id;
        conn_cluster[0][1] = row1_id;
        conn_cluster[1][0] = col2_id;
        conn_cluster[1][1] = row2_id;
        int cluster_index = 2;
        for (int j = i + 1; j < counter; j = j + 1) {
        // const int connj[5] = conn_indicator[j]; // Fix: No implemented yet
            if (conn_indicator[j][0] == conn_id) {
                const int col1_id_j = conn_indicator[j][1];
                const int row1_id_j = conn_indicator[j][2];
                const int col2_id_j = conn_indicator[j][3];
                const int row2_id_j = conn_indicator[j][4];

                // Put the different cells in the same cluster
                int already_in_cluster_col1 = 0;
                int already_in_cluster_col2 = 0;
                for (int k = 0; k < cluster_index; k = k + 1) {
                    if (col1_id_j == conn_cluster[k][0] && row1_id_j == conn_cluster[k][1]) {
                        already_in_cluster_col1 = 1;
                    }
                    if (col2_id_j == conn_cluster[k][0] && row2_id_j == conn_cluster[k][1]) {
                        already_in_cluster_col2 = 1;
                    }
                    if (already_in_cluster_col1 && already_in_cluster_col2) {
                        break; // Both are already in the cluster, no need to continue
                    }
                }

                if (!already_in_cluster_col1) {
                    conn_cluster[cluster_index][0] = col1_id_j;
                    conn_cluster[cluster_index][1] = row1_id_j;
                    cluster_index = cluster_index + 1;
                }

                if (!already_in_cluster_col2) {
                    conn_cluster[cluster_index][0] = col2_id_j;
                    conn_cluster[cluster_index][1] = row2_id_j;
                    cluster_index = cluster_index + 1;
                }

                // remove the element conn_indicator[j] from the list
                for (int k = j; k < counter - 1; k = k + 1) {
                    conn_indicator[k] = conn_indicator[k+1];
                }
                counter = counter - 1;
            }
        }

        // Rotate the cells in the cluster
        for (int j = 0; j < cluster_index - 1; j = j + 1) {
            const int col1_id_clust = conn_cluster[j][0];
            const int row1_id_clust = conn_cluster[j][1];
            const int col2_id_clust = conn_cluster[j+1][0];
            const int row2_id_clust = conn_cluster[j+1][1];

            const int tmp = PERs[col1_id_clust][row1_id_clust];
            PERs[col1_id_clust][row1_id_clust] = PERs[col2_id_clust][row2_id_clust];
            PERs[col2_id_clust][row2_id_clust] = tmp;
        }
    }

    // Send to the bus the original columns and the permuted columns
    for (int i = 0; i < cols_num; i = i + 1) {
        prod_assumes_nosel(name_connection, opid, [map_cols[i], air.std.connect.IDs[i]]); // TODO: Should I generate the assume here or at the beggining?
        prod_proves_nosel(name_connection, opid, [map_cols[i], PERs[i]]);
    }

    // Mark the connection as closed
    closed = 1;
}

private function find_col_index(int opid, expr column): int {
    use air.std.connect.`id${opid}`;

    for (int i = 0; i < cols_num; i = i + 1) {
        if (map_cols[i] == column) {
            return i;
        }
    }

    error(`Column ${column} was not defined in connect #${opid}`);
}

private function checkClosed() {
    for (int i = 0; i < air.std.connect.opids_count; i = i + 1) {
        const int opid = air.std.connect.opids[i];
        use air.std.connect.`id${opid}`;
        if (closed == 0) {
            error(`Connection #${opid} was never closed`);
        }
    }
}

// 2] Interface where the user knows both the inputs (placed in assumes) and the
//    permutation (placed in proves) of the argument.

/**
 * TODO
 *
 * @param {int} opid - The (unique) identifier of the connection
 * @param {expr[]} cols - Array of columns to be connected
 * @param {expr[]} conn - Fixed columns indicating the connection
 * @example
 * col witness a,b,c;
 * col fixed S1,S2,S3;
 * // Compute S1, S2, S3...
 * connection(opid, [a, b, c], [S1, S2, S3]);
 * connection(opid, [a, b, c], [S1, S2, S3], N/2);
 */
function connection(int opid, expr cols[], expr conn[]) {
    const int len = length(cols);
    if (len == 0) {
        error(`Connection #${opid} cannot be empty`);
    } else if (len != length(conn)) {
        error(`The number of columns and  of connect #${opid} must be the same`);
    }

    // Reuse the possibly defined IDs
    if (defined(air.std.connect)) {
        use air.std.connect;

        // If the container has been created at some point, ids_count cannot be 0
        for (int i = ids_count; i < len; i = i + 1) {
            const int k = Goldilocks_k ** i;
            for (int j = 0; j < N; j = j + 1) {
                IDs[i][j] = k * IDs[0][j];
            }
        }

        // Send to the bus the original columns and the permuted columns
        for (int i = 0; i < len; i = i + 1) {
            prod_assumes_nosel(name_connection, opid, [cols[i], IDs[i]]);
            prod_proves_nosel(name_connection, opid, [cols[i], conn[i]]);
        }
    } else {
        col fixed IDs[len];

        IDs[0] = [1,GEN[BITS]..*..]; // {1,𝛚,𝛚²,...,𝛚ᴺ⁻¹}
        // Send to the bus the first column and its associated permuted column
        prod_assumes_nosel(name_connection, opid, [cols[0], IDs[0]]);
        prod_proves_nosel(name_connection, opid, [cols[0], conn[0]]);

        for (int i = 1; i < len; i = i + 1) {
            const int k = Goldilocks_k ** i;
            for (int j = 0; j < N; j = j + 1) {
                IDs[i][j] = k * IDs[0][j];
            }

            // Send to the bus the rest original columns and their permuted columns
            prod_assumes_nosel(name_connection, opid, [cols[i], IDs[i]]);
            prod_proves_nosel(name_connection, opid, [cols[i], conn[i]]);
        }
    }
}
