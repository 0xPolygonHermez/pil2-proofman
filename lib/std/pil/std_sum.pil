require "std_common.pil";

function sum_assumes(string type, int opid, expr sel = 1, expr cols[]) {
    update_piop_sum(type, 0, [opid], opid, sel, cols);
}

function sum_proves(string type, int opid, expr mul = 1, expr cols[]) {
    update_piop_sum(type, 1, [opid], opid, mul, cols);
}

function sum_assumes_dynamic(string type, int opid[], expr sumid, expr sel = 1, expr cols[]) {
    update_piop_sum(type, 0, opid, sumid, sel, cols);
}

/**
 * It performs initial checks and initializes the containers for the grandsum
 * @param type type of the PIOP
 * @param proves 1 if proves, 0 if assumes
 * @param opid (unique) identifier of the PIOP check
 * @param cols columns of the PIOP
 */
private function init_piop_sum(string type, int proves, int opid[], expr cols[]) {
    const int cols_count = length(cols);

    if (cols_count < 1) {
        string side = proves ? "proves" : "assumes";
        error(`The number of columns in ${side} of ${type} #${opid} must be at least 1`);
    }

    container proof.std.gsum alias gsum {
        // FIX: dynamic arrays not ready
        int opids_count = 0;
        int opids[100];
        expr gsum = 0;  // Resulting sum of every airgroup and every air.
                        // Declared as expression (unknown at runtime), but used as field element.
    }

    container airgroup.std.gsum {
        airgroupval aggregate(sum) gsum_result;
    }

    container air.std.gsum {
        int gsum_assumes_count = 0;
        expr gsum_assumes_sel[100];
        expr gsum_assumes[100];

        int gsum_proves_count = 0;
        expr gsum_proves_mul[100];
        expr gsum_proves[100];
    }

    // Container used for final checks
    for (int i = 0; i < length(opid); i++) {
        container proof.std.gsum.`id${opid[i]}` alias gsumid {
            string type = type;
            int cols;
            int proves = 0;
            int assumes = 0;
        }

        // Assumes and proves of the same opid must have the same number of columns
        if (gsumid.cols == 0) {
            // first time called
            gsumid.cols = cols_count;

            // add opid on a list to verify at final
            gsum.opids[gsum.opids_count] = opid[i];
            gsum.opids_count++;
        } else if (gsumid.cols != cols_count) {
            error(`The number of columns of PIOP #${opid[i]} must be ${gsumid.cols} but was ${cols_count}`);
        }

        // The same opid is shared among multiple instances of the same air, so we must keep track of the number of
        // proves and assumes to verify at the end that all of them match
        if (proves) {
            gsumid.proves++;
        } else {
            gsumid.assumes++;
        }
    }
}

/**
 * Given a selector sel and columns C₀,...,Cₙ₋₁, it:
 *      · 1] defines the running grandsum constraints for each air
 *      · 2] add each airgroupvalue of each airgroup to the running sum
 *      · 3] checks that the overall sum is zero
 * @param type type of the PIOP
 * @param proves boolean indicating if updating a proves or a assumes
 * @param opid (unique) identifier of the PIOP
 * @param sel selector of the PIOP
 * @param cols columns of the PIOP
 */
private function update_piop_sum(string type, int proves, int opid[], expr sumid, expr sel, expr cols[]) {
    // instanciate necessary containers and make first checks
    init_piop_sum(type, proves, opid, cols);

    init_challenges();

    // selected vector to simple column reduction
    expr cols_compressed = compress_cols(sumid, cols);

    use air.std.gsum;
    if (proves) {
        // adding all sums of proves called in this air
        gsum_proves_mul[gsum_proves_count] = sel;
        gsum_proves[gsum_proves_count] = cols_compressed;
        gsum_proves_count = gsum_proves_count + 1;
    } else {
        // adding all sums of assumes called in this air
        gsum_assumes_sel[gsum_assumes_count] = sel;
        gsum_assumes[gsum_assumes_count] = cols_compressed;
        gsum_assumes_count = gsum_assumes_count + 1;
    }

    // TODO: look for repeated proves/assumes's in both lookups and range checks and, if found, optimize ???

    // define constraints at the air level
    on final air piop_gsum_air();

    // update values at the airgroup level
    on final airgroup piop_gsum_airgroup();

    // update constraints at the proof level
    on final proof piop_gsum_proof();
}

/**
 * It defines the constraints for the grandsum based on the logUp protocol https://eprint.iacr.org/2022/1530.pdf
 */
private function piop_gsum_air() {
    use air.std.gsum;

    col witness stage(2) gsum;

    //                                mt1       mt2       sf1      sf2
    //  gsum === 'gsum * (1 - L1) + ------- + ------- - ------- - -------
    //                              t1 + ɣ    t2 + ɣ    f1 + ɣ    f2 + ɣ
    //
    // Note: The ti and fi are not necessarily related to each other

    col fixed __L1 = [1,0...]; // TODO: Fix

    expr LHS = 1;
    expr RHS1 = 0;

    for (int i = 0; i < gsum_proves_count; i = i + 1) {
        LHS = LHS * (gsum_proves[i] + std_gamma);

        expr tmp = gsum_proves_mul[i];
        for (int j = 0; j < gsum_proves_count; j = j + 1) {
            if (j != i) tmp = tmp * (gsum_proves[j] + std_gamma);
        }
        RHS1 = RHS1 + tmp;
    }

    expr RHS2a = LHS;
    expr RHS2b = 0;

    for (int i = 0; i < gsum_assumes_count; i = i + 1) {
        LHS = LHS * (gsum_assumes[i] + std_gamma);
        RHS1 = RHS1 * (gsum_assumes[i] + std_gamma);

        expr tmp = gsum_assumes_sel[i];
        for (int j = 0; j < gsum_assumes_count; j = j + 1) {
            if (j != i) tmp = tmp * (gsum_assumes[j] + std_gamma);
        }
        RHS2b = RHS2b + tmp;
    }

    expr RHS2 = RHS2a * RHS2b;
    expr RHS = RHS1 - RHS2;

    @gsum_col{reference: gsum, numerator: RHS, denominator: LHS, result: airgroup.std.gsum.gsum_result};

    (gsum - 'gsum * (1 - __L1)) * LHS === RHS;
    __L1' * (gsum - airgroup.std.gsum.gsum_result) === 0;
}

// Note: We don't "update" the sum at the airgroup level (i.e., all the resulting sums generated by each air)
//       because we don't know how many airs will be generated at compile time. Therefore we use the same
//       term to refer to both things: the value generated at each air and the value generated at each airgroup.
//       It is like jumping from the air level to the proof (global) level, from the constraint point of view.

/**
 * It updates the expression for the grandsum at the proof level
 */
private function piop_gsum_airgroup() {
    proof.std.gsum.gsum = proof.std.gsum.gsum + airgroup.std.gsum.gsum_result;
}

/**
 * It defines the constraints for the grandsum at the proof level
 */
private function piop_gsum_proof() {
    check_gsum_was_completed();

    proof.std.gsum.gsum === 0;
}

/**
 * It checks that all the assumes and proves of the same opid have been defined
 */
private function check_gsum_was_completed() {
    for (int index = 0; index < proof.std.gsum.opids_count; index = index + 1) {
        int opid = proof.std.gsum.opids[index];
        use proof.std.gsum.`id${opid}`;
        if (assumes == 0) {
            error(`${type} #${opid} defined without assume`);
        } else if (proves == 0) {
            error(`${type} #${opid} defined without proves`);
        }
    }
}