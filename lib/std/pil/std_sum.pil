require "std_common.pil";

function sum_assumes(const string type, const int opid, const expr cols[], const expr sel = 1) {
    update_piop_sum(type, 0, [opid], opid, sel, cols);
}

function sum_proves(const string type, const int opid, const expr cols[], const expr mul = 1, const int is_direct = 0) {
    update_piop_sum(type, 1, [opid], opid, mul, cols, is_direct);
}

function sum_assumes_dynamic(const string type, const int opid[], const expr sumid, const expr cols[], const expr sel = 1) {
    update_piop_sum(type, 0, opid, sumid, sel, cols);
}

private function init_containers_sum(string type, int opid[]) {
    container proof.std.gsum {
        // FIX: dynamic arrays not ready
        int opids_count = 0;
        int opids[100];
        expr gsum = 0;  // Resulting sum of every airgroup and every air.
                        // Declared as expression (unknown at runtime), but used as field element.
    }

    container airgroup.std.gsum {
        airgroupval aggregate(sum) gsum_result;

        int direct_gsum_count = 0;
        expr direct_gsum[100];
    }

    container air.std.gsum {
        int gsum_assumes_count = 0;
        expr gsum_assumes_sel[100];
        expr gsum_assumes[100];

        int gsum_proves_count = 0;
        expr gsum_proves_mul[100];
        expr gsum_proves[100];
    }

    // Container used for final checks
    for (int i = 0; i < length(opid); i++) {
        container proof.std.gsum.`id${opid[i]}` {
            string type = type;
            int cols;
            int proves = 0;
            int assumes = 0;
        }
    }
}

private function initial_checks_sum(int proves, int opid[], expr cols[]) {
    const int cols_count = length(cols);

    if (cols_count < 1) {
        string side = proves ? "proves" : "assumes";
        error(`The number of columns in ${side} of ${type} #${opid} must be at least 1`);
    }

    for (int i = 0; i < length(opid); i++) {
        // Assumes and proves of the same opid must have the same number of columns
        if (proof.std.gsum.`id${opid[i]}`.cols == 0) {
            // first time called
            proof.std.gsum.`id${opid[i]}`.cols = cols_count;

            // add opid on a list to verify at final
            proof.std.gsum.opids[proof.std.gsum.opids_count] = opid[i];
            proof.std.gsum.opids_count++;
        } else if (cols_count != proof.std.gsum.`id${opid[i]}`.cols) {
            const int expected_cols = proof.std.gsum.`id${opid[i]}`.cols;
            error(`The number of columns of PIOP #${opid[i]} must be ${expected_cols} but was ${cols_count}`);
        }

        // The same opid is shared among multiple instances of the same air, so we must keep track of the number of
        // proves and assumes to verify at the end that all of them match
        if (proves) {
            proof.std.gsum.`id${opid[i]}`.proves++;
        } else {
            proof.std.gsum.`id${opid[i]}`.assumes++;
        }
    }
}

/**
 * Given a selector sel and columns C₀,...,Cₙ₋₁, it:
 *      · 1] defines the running grandsum constraints for each air
 *      · 2] add each airgroupvalue of each airgroup to the running sum
 *      · 3] checks that the overall sum is zero
 * @param type type of the PIOP
 * @param proves boolean indicating if updating a proves or a assumes
 * @param opid (unique) identifier of the PIOP
 * @param sel selector of the PIOP
 * @param cols columns of the PIOP
 */
private function update_piop_sum(string type, int proves, int opid[], expr sumid, expr sel, expr cols[], int is_direct = 0) {
    init_containers_sum(type, opid);

    if (!is_direct) initial_checks_sum(proves, opid, cols);

    init_challenges();

    // selected vector to simple column reduction
    expr cols_compressed = compress_cols(sumid, cols);

    if (is_direct) {
        use airgroup.std.gsum;

        // adding the expression from which the proof constraint will be directly updated
        direct_gsum[direct_gsum_count] = sel * (cols_compressed - 1) + 1;
        direct_gsum_count++;

        // update values at the airgroup level
        on final airgroup piop_gsum_airgroup_direct();
    } else {
        use air.std.gsum;
        if (proves) {
            // adding all sums of proves called in this air
            gsum_proves_mul[gsum_proves_count] = sel;
            gsum_proves[gsum_proves_count] = cols_compressed;
            gsum_proves_count++;
        } else {
            // adding all sums of assumes called in this air
            gsum_assumes_sel[gsum_assumes_count] = sel;
            gsum_assumes[gsum_assumes_count] = cols_compressed;
            gsum_assumes_count++;
        }

        // define constraints at the air level
        on final air piop_gsum_air();

        // update values at the airgroup level
        on final airgroup piop_gsum_airgroup();
    }

    // TODO: look for repeated proves/assumes's in both lookups and range checks and, if found, optimize ???

    // update constraints at the proof level
    on final proof piop_gsum_proof();
}

/**
 * It defines the constraints for the grandsum based on the logUp protocol https://eprint.iacr.org/2022/1530.pdf
 */
private function piop_gsum_air(int nTerms = 2) {
    use air.std.gsum;

    const int nIm1 = gsum_proves_count/nTerms;
    const int nIm2 = gsum_assumes_count/nTerms;

    col witness stage(2) im[nIm1 + nIm2];

    col fixed __L1 = [1,0...]; // TODO: Fix
    col witness stage(2) gsum;

    /*
                                            muli       seli
        gsum === 'gsum * (1 - L1) + ∑ᵢ ( -------- - -------- )
                                           ti + ɣ     fi + ɣ

    Note: The ti and fi are not necessarily related to each other
    */

    expr posIms = 0;
    for (int i = 0; i < nIm1; i++) {

        //            mul[3*i]           mul[3*i+1]          mul[3*i+2]
        // im[i] = --------------- + ----------------- + -----------------
        //            t[3*i] + ɣ        t[3*i+1] + ɣ        t[3*i+2] + ɣ
        expr tProds = 1;
        expr tSums = 0;
        for (int j = 0; j < nTerms; j++) {
            tProds *= (gsum_proves[nTerms * i + j] + std_gamma);

            expr tPartial = gsum_proves_mul[nTerms * i + j];
            for (int k = 0; k < nTerms; k++) {
                if (k == j) continue;
                tPartial *= (gsum_proves[nTerms * i + k] + std_gamma);
            }
            tSums += tPartial;
        }
        @im_col{reference: im[i], numerator: tSums, denominator: tProds};

        // im[i] * t[3*i] * t[3*i+1] * t[3*i+2] ===
        //                    mul[3*i]*t[3*i+1]*t[3*i+2] + mul[3*i+1]*t[3*i]*t[3*i+2] + mul[3*i+2]*t[3*i]*t[3*i+1];
        im[i] * tProds === tSums;

        posIms += im[i];
    }

    if (gsum_proves_count % nTerms != 0) {
        col witness stage(2) im_extra_pos;

        // This col is defined with a number of terms between 1 and nTerms-1
        const int nRemTerms = gsum_proves_count % nTerms;

        expr tProds = 1;
        expr tSums = 0;
        for (int j = 0; j < nRemTerms; j++) {
            tProds *= (gsum_proves[nTerms * nIm1 + j] + std_gamma);

            expr tPartial = gsum_proves_mul[nTerms * nIm1 + j];
            for (int k = 0; k < nRemTerms; k++) {
                if (k == j) continue;
                tPartial *= (gsum_proves[nTerms * nIm1 + k] + std_gamma);
            }
            tSums += tPartial;
        }
        @im_col{reference: im_extra_pos, numerator: tSums, denominator: tProds};

        im_extra_pos * tProds === tSums;

        posIms += im_extra_pos;
    }

    expr negIms = 0;
    for (int i = 0; i < nIm2; i++) {

        //                  sel[3*i]         sel[3*i+1]           sel[3*i+2]
        // im[nIm1+i] = --------------- + ----------------- + -----------------
        //                f[3*i] + ɣ        f[3*i+1] + ɣ        f[3*i+2] + ɣ
        expr fProds = 1;
        expr fSums = 0;
        for (int j = 0; j < nTerms; j++) {
            fProds *= (gsum_assumes[nTerms * i + j] + std_gamma);

            expr fPartial = gsum_assumes_sel[nTerms * i + j];
            for (int k = 0; k < nTerms; k++) {
                if (k == j) continue;
                fPartial *= (gsum_assumes[nTerms * i + k] + std_gamma);
            }
            fSums += fPartial;
        }
        @im_col{reference: im[nIm1+i], numerator: fSums, denominator: fProds};

        // im[i] * t[3*i] * t[3*i+1] * t[3*i+2] ===
        //                    mul[3*i]*t[3*i+1]*t[3*i+2] + mul[3*i+1]*t[3*i]*t[3*i+2] + mul[3*i+2]*t[3*i]*t[3*i+1];
        im[nIm1+i] * fProds === fSums;

        negIms += im[nIm1+i];
    }

    if (gsum_assumes_count % nTerms != 0) {
        col witness stage(2) im_extra_neg;

        // This col is defined with a number of terms between 1 and nTerms-1
        const int nRemTerms = gsum_assumes_count % nTerms;

        expr fProds = 1;
        expr fSums = 0;
        for (int j = 0; j < nRemTerms; j++) {
            fProds *= (gsum_assumes[nTerms * nIm2 + j] + std_gamma);

            expr fPartial = gsum_assumes_sel[nTerms * nIm2 + j];
            for (int k = 0; k < nRemTerms; k++) {
                if (k == j) continue;
                fPartial *= (gsum_assumes[nTerms * nIm2 + k] + std_gamma);
            }
            fSums += fPartial;
        }
        @im_col{reference: im_extra_neg, numerator: fSums, denominator: fProds};

        im_extra_neg * fProds === fSums;

        negIms += im_extra_neg;
    }

    @gsum_col{reference: gsum, expression: posIms - negIms, result: airgroup.std.gsum.gsum_result};

    gsum === 'gsum * (1 - __L1) + posIms - negIms;
    __L1' * (gsum - airgroup.std.gsum.gsum_result) === 0;
}

// Note: We don't "update" the sum at the airgroup level (i.e., all the resulting sums generated by each air)
//       because we don't know how many airs will be generated at compile time. Therefore we use the same
//       term to refer to both things: the value generated at each air and the value generated at each airgroup.
//       It is like jumping from the air level to the proof (global) level, from the constraint point of view.

/**
 * It updates the expression for the grandsum at the proof level
 */
private function piop_gsum_airgroup() {
    proof.std.gsum.gsum += airgroup.std.gsum.gsum_result;
}

/**
 * It It updates the expression for the grandprod at the proof level directly
 */
private function piop_gsum_airgroup_direct() {
    use airgroup.std.gsum;
    for (int i = 0; i < direct_gsum_count; i++) {
        proof.std.gsum.gsum += direct_gsum[i];
    }
}

/**
 * It defines the constraints for the grandsum at the proof level
 */
private function piop_gsum_proof() {
    check_gsum_was_completed();

    proof.std.gsum.gsum === 0;
}

/**
 * It checks that all the assumes and proves of the same opid have been defined
 */
private function check_gsum_was_completed() {
    for (int index = 0; index < proof.std.gsum.opids_count; index = index + 1) {
        int opid = proof.std.gsum.opids[index];
        use proof.std.gsum.`id${opid}`;
        if (assumes == 0) {
            error(`${type} #${opid} defined without assume`);
        } else if (proves == 0) {
            error(`${type} #${opid} defined without proves`);
        }
    }
}