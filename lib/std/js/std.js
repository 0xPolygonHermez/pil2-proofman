const { WitnessCalculatorComponent } = require("pil2-proofman/src/witness_calculator_component.js");

const log = require("pil2-proofman/logger.js");

const RangeCheck = require("./std_range_check.js");
const Sum = require("./std_sum.js");
const Prod = require("./std_prod.js");

module.exports = class STD extends WitnessCalculatorComponent {
    constructor(wcManager, proofCtx) {
        super("STD", wcManager, proofCtx);

        this.terminate = false;

        this.components = {};

        this.#initializeComponents();
    }

    #initializeComponents() {
        this.components['RangeCheck'] = new RangeCheck(this.wcManager, this.proofCtx);
        this.components['Sum'] = new Sum(this.wcManager, this.proofCtx);
        this.components['Prod'] = new Prod(this.wcManager, this.proofCtx);
    }

    setupRangeCheck(airInstance) {
        const RC = this.components['RangeCheck'];
        return RC.setup(airInstance);
    }

    rangeCheck(value, min, max) {
        const RC = this.components['RangeCheck'];
        RC.assignValues(value, min, max);
    }

    async witnessComputation(stageId, subproofId, airInstance, publics) {
        log.info(`[${this.name}       ]`, `Starting witness computation stage ${stageId}.`);

        // NOTE: The STD does not have multiple airs, it is not even a subproof by itself
        airInstance.airId = 0;

        // Find subproofs generated by the std "in the air"
        const rangeCheckAirs = this.proofCtx.airout.subproofs.filter(h => this.components['RangeCheck'].subproofs.includes(h.name));

        if (stageId === 1) {
            // Compute the associated witness when the std is called from the std-generated subproofs
            if (rangeCheckAirs.find(h => h.subproofId === subproofId)) {
                const instanceId = airInstance.instanceId;

                if (instanceId !== -1) {
                    log.error(`[${this.name}]`, `Air instance id already existing in stageId 1.`);
                    throw new Error(`[${this.name}]`, `Air instance id already existing in stageId 1.`);
                }

                const air = this.proofCtx.airout.subproofs[subproofId].airs[airInstance.airId];

                let result = this.proofCtx.addAirInstance(subproofId, airInstance, air.numRows);

                if (result === false) {
                    log.error( `[${this.name}]`,`New air instance for air '${air.name}' with N=${air.numRows} rows failed.`);
                    throw new Error(`[${this.name}]`,`New air instance for air '${air.name}' with N=${air.numRows} rows failed.`);
                }

                // Now, we should wait till the left-side of the range check is found
                while (!this.terminate) {
                    let mailbox = await this.receiveData();
                    let rangeCheckComputed = false;
                    for (let i = 0; i < mailbox.length; i++) {
                        const msg = mailbox[i];
                        // TODO 1: It seems that under the current model I cannot compute in parallel all the subproof witness.
                        // Hence, what I do is generating a notification from the range check computator to the std
                        // and compute the subsequent witness if necessary
                        if ((msg.type && msg.payload.data) && (msg.type === 'notification' && msg.payload.data === 'finished')) {
                            // The first one should go after the subproof that contains range check have finished, since the multiplicity
                            // depends on that trace
                            const subproofHints = this.proofCtx.setup.setup[msg.payload.subproofId][msg.payload.airId].expressionsInfo.hintsInfo;
                            const rcHints = subproofHints.filter(h => h.name === 'range_check');
                            if (rcHints.length > 0) {
                                await this.components['RangeCheck'].witnessComputation(stageId, subproofId, airInstance, publics);
                                rangeCheckComputed = true;
                            }
                        } else if ((msg.sender && msg.command) && (msg.sender === this.components['RangeCheck'].name && msg.command == 'continueSubsequentSubproof')) {
                            await this.components['RangeCheck'].witnessComputation(stageId, subproofId, airInstance, publics);
                            rangeCheckComputed = true;
                        }
                    }

                    if (rangeCheckComputed) this.terminate = true;
                }
            }
        }

        if (stageId === 2) {
            // TODO: Subproofs that do not send a notification when they finish, since they are not part of the config
            for (const rcair of rangeCheckAirs) {
                if (rcair.subproofId == subproofId) {
                    // Note: there will never be more than once air and instance for this subproof
                    await this.decider(2, rcair.subproofId, 0, 0, publics);
                    return;
                }
            }

            // TODO: Subproofs that do send a notification when they finish, since they are part of the config
            const mailbox = await this.receiveData();
            for (let i = 0; i < mailbox.length; i++) {
                const msg = mailbox[i];
                if (msg.type === 'notification' && msg.payload.data === 'finished') {
                    await this.decider(msg.payload.stageId, msg.payload.subproofId, msg.payload.airId, msg.payload.instanceId, publics);
                }
            }
        }

        log.info(`[${this.name}       ]`, `Finishing witness computation stage ${stageId}.`);
        return;
    }

    // This function should decide what to call in the std depending on what the pilout specifies
    async decider(stageId, subproofId, airId, instanceId, publics) {
        const instanceToProcess = this.proofCtx.getAirInstancesBySubproofIdAirId(subproofId,airId)[instanceId];
        const hints = this.proofCtx.setup.setup[subproofId][airId].expressionsInfo.hintsInfo;

        const hints_sum = hints.filter(h => h.name === 'gsum_col' || h.name === 'im_col');
        const hints_prod = hints.find(h => h.name === 'gprod_col');
        console.log(hints_sum);
        extendWith;

        if (hints_sum) {
            await this.components['Sum']._witnessComputation(stageId, subproofId, instanceToProcess, publics, hints_sum);
        }

        if (hints_prod) {
            await this.components['Prod']._witnessComputation(stageId, subproofId, instanceToProcess, publics, hints_prod);
        }
    }
}
