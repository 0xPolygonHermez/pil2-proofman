<%  let mut c = 0; %>
<%  for i in 0..global_info.n_challenges.len() { %>
<%      for j in 0..global_info.n_challenges[i] { %>
<%          if i < stark_info.n_stages as usize &&
            stark_info.challenges_map.as_ref()
                .map(|challenges_map| challenges_map.iter().filter(|&map| map.stage == (i + 1) as u64).count())
                .unwrap_or(0) > j { %>
    <%= component_name %>.challengesStage<%= i + 1 %>[<%= j %>] <== challenges[<%= c %>];
<%          } %>
<%          c += 1; %>
<%      } %>
<%  } %>

    <%= component_name %>.challengeQ <== challenges[<%= c %>];
    <%= component_name %>.challengeXi <== challenges[<%= c+1 %>];
    <%= component_name %>.challengesFRI[0] <== challenges[<%= c+2 %>];
    <%= component_name %>.challengesFRI[1] <== challenges[<%= c+3  %>];

<%  c = 0; %>
<%  for i in 0..global_info.steps_fri.len() { %>
<%      if c < stark_info.stark_struct.steps.len() && stark_info.stark_struct.steps[c].n_bits == global_info.steps_fri[i].n_bits as u64 { %>
    <%= component_name %>.challengesFRISteps[<%= c %>] <== challengesFRISteps[<%= i %>];
<%      c += 1; %>
<%      } %>
<%  } %>
    <%= component_name %>.challengesFRISteps[<%= stark_info.stark_struct.steps.len() %>] <== challengesFRISteps[<%= global_info.steps_fri.len() %>];


<%  let circuit_type = if global_info.air_groups.len() > 1 || global_info.airs[0].len() > 1 { stark_info.air_id.unwrap_or(0) + 2 } else { stark_info.air_id.unwrap_or(0) + 1 }; %>
    <%= prefix_vadcop %>circuitType <== <%= circuit_type %>;
    
<%  if global_info.agg_types[stark_info.airgroup_id.unwrap() as usize].len() > 0  { %>
    <%= prefix_vadcop %>aggregationTypes <== [<%= global_info.agg_types[stark_info.airgroup_id.unwrap() as usize].iter().map(|a| a.agg_type.to_string()).collect::<Vec<String>>().join(",") %>];
<%  } %>

<%  if global_info.agg_types[stark_info.airgroup_id.unwrap() as usize].len() > 0  { %>
<%      for i in 0..global_info.agg_types[stark_info.airgroup_id.unwrap() as usize].len() { %>
    <%= prefix_vadcop %>airgroupvalues[<%= i %>] <== <%= prefix %>airgroupvalues[<%= i %>];
<%      } %>
<%  } %>


<%  for i in 0..stark_info.n_stages { %>
<%  let air_values_exist = stark_info.airvalues_map.as_ref().map_or(false, |map| map.iter().any(|a| a.stage == (i + 1) as u64)); %>
<%  if i == 0 { %>
<%  if air_values_exist { %>
    <%= prefix_vadcop %>root<%= i+1 %> <== CalculateStage<%= i+1 %>Hash()(<%= component_name %>.rootC, <%= prefix%>root<%= i+1 %>, <%= prefix %>airvalues);
<%  } else { %>
    <%= prefix_vadcop %>root<%= i+1 %> <== CalculateStage<%= i+1 %>Hash()(<%= component_name %>.rootC, <%= prefix%>root<%= i+1 %>);
<%  } %>
<%  } else { %>
<%  if air_values_exist { %>
    <%= prefix_vadcop %>root<%= i+1 %> <== CalculateStage<%= i+1 %>Hash()(<%= prefix%>root<%= i+1 %>, <%= prefix %>airvalues);
<%  } else { %>
    <%= prefix_vadcop %>root<%= i+1 %> <== <%= prefix %>root<%= i+1 %>;
<%  } %>
<%  } %>
<%  } %>
<%  for i in stark_info.n_stages..global_info.n_challenges.len() as u32 { %>
    <%= prefix_vadcop %>root<%= i+1 %> <== [0,0,0,0];
<%  } %>

    <%= prefix_vadcop %>root<%= stark_info.n_stages + 1 %> <== <%= prefix %>root<%= stark_info.n_stages + 1 %>;

    <%= prefix_vadcop %>evalsHash <== CalculateEvalsHash()(<%= prefix %>evals);

<%  let mut fri_counter = 0; %>
<%  for i in 1..global_info.steps_fri.len() { %>
<%     if fri_counter < stark_info.stark_struct.steps.len() - 1 && stark_info.stark_struct.steps[fri_counter].n_bits == global_info.steps_fri[i - 1].n_bits  as u64 { %>
    <%= prefix_vadcop %>s<%= i %>_root <== <%= prefix %>s<%= fri_counter %>_root;
<% fri_counter += 1; %>
<%     } else { %>
    <%= prefix_vadcop %>s<%= i %>_root <== [0,0,0,0];
<%     } %>
<%  } %>
    
    <%= prefix_vadcop %>finalPolHash <== CalculateFinalPolHash()(<%= prefix %>finalPol);