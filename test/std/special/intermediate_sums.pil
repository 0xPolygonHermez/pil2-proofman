require "std_lookup.pil";

/*
TODO: There is no stage 3 in fact, with two stages is sufficient!!!!
TODO: Does it makes sense for the std to define a specific stage? How this is read with the setup? Should we name the stages for reference?

Table of generated numbers (*):

#BusCalls | Self | Selt | #Cols1 |   #Cols2   | #Cols3 | #Total | Expression
──────────┼──────┼──────┼────────┼────────────┼────────┼────────┼─────────────────────────────────────────────────────────────────────────────────────────────
          |      |      |        |            |        |        |                       mul1     mul2        1         1
    2     |  0   |  0   |   6    | 2 (1 im)/6 |   3/9  |  11/21 | S = 'S * (1 - L1) + ------- + ------- - ------- - -------
          |      |      |        |            |        |        |                     t1 + ɣ    t2 + ɣ    f1 + ɣ    f2 + ɣ
──────────┼──────┼──────┼────────┼────────────┼────────┼────────┼─────────────────────────────────────────────────────────────────────────────────────────────
          |      |      |        |            |        |        |          mul1         mul2               1            1
    2     |  0   |  0   |   6    | 3 (0 im)/9 |   2/6  |  11/21 | im1 = ---------- + ----------, im2 = ---------- + ----------, S = 'S * (1 - L1) + im1 - im2
          |      |      |        |            |        |        |         t1 + ɣ       t2 + ɣ           f1 + ɣ       f2 + ɣ
──────────┼──────┼──────┼────────┼────────────┼────────┼────────┼─────────────────────────────────────────────────────────────────────────────────────────────

(*) Numbers assume a blowup factor of 2
*/

airtemplate SimpleSum(int N = 2**2) {

    col witness f1,f2,t1,t2;
    col witness mul1,mul2;

    col witness stage(2) gsum;
    //                                mul1     mul2        1         1
    //  gsum === 'gsum * (1 - L1) + ------- + ------- - ------- - -------
    //                              t1 + ɣ    t2 + ɣ    f1 + ɣ    f2 + ɣ

    col fixed L1 = [1,0...];

    expr numerator1 = mul1 * (t2 + std_gamma) * (f1 + std_gamma) * (f2 + std_gamma) + mul2 * (t1 + std_gamma) * (f1 + std_gamma) * (f2 + std_gamma);
    expr numerator2 = (t1 + std_gamma) * (t2 + std_gamma) * (f2 + std_gamma) + (t1 + std_gamma) * (t2 + std_gamma) * (f1 + std_gamma);
    expr numerator = numerator1 - numerator2;
    expr denominator = (t1 + std_gamma) * (t2 + std_gamma) * (f1 + std_gamma) * (f2 + std_gamma);

    (gsum - 'gsum * (1 - L1)) * denominator === numerator;
}

airtemplate OptimizedSum(int N = 2**2) {

    col witness f1,f2,t1,t2;
    col witness mul1,mul2;

    col witness stage(2) im1;
    //          mul1         mul2
    // im1 = ---------- + ----------
    //         t1 + ɣ       t2 + ɣ

    expr numerator = mul1 * (t2 + std_gamma)  + mul2 * (t1 + std_gamma);
    expr denominator = (t1 + std_gamma) * (t2 + std_gamma);

    @im1{reference: im1, numerator: numerator, denominator: denominator};

    im1 * denominator === numerator;

    col witness stage(2) im2;
    //            1            1
    // im2 = ---------- + ----------
    //         f1 + ɣ       f2 + ɣ

    numerator = (f2 + std_gamma)  + (f1 + std_gamma);
    denominator = (f1 + std_gamma) * (f2 + std_gamma);

    @im2{reference: im2, numerator: numerator, denominator: denominator};

    im2 * denominator === numerator;

    col witness stage(2) gsum;
    //  gsum === 'gsum * (1 - L1) + im1 - im2

    col fixed L1 = [1,0...];

    gsum === 'gsum * (1 - L1) + im1 - im2;
}

airgroup Sum {
    init_challenges();

    // SimpleSum();
    OptimizedSum();
}