require "std_lookup.pil";

/*
TODO: Does it makes sense for the std to define a specific stage? How this is read with the setup? Should we name the stages for reference?

Table of generated numbers (*):

#BusCalls | Pair | Self | Selt | #Cols1 |   #Cols2    | #Cols3 | #Total | #Constraints |
──────────┼──────┼──────┼──────┼────────┼─────────────┼────────┼────────┼──────────────┼
    2     |  0   |  0   |  0   |   6    | 4 (3 im)/12 |   2/6  |  12/24 |      4       |
──────────┼──────┼──────┼──────┼────────┼─────────────┼────────┼────────┼──────────────┼
    2     |  1   |  0   |  0   |   6    | 3 (0 im)/9  |   2/6  |  11/21 |      3       |
──────────┼──────┼──────┼──────┼────────┼─────────────┼────────┼────────┼──────────────┼

(*) Numbers assume a blowup factor of 1
*/

airtemplate Intermediates(int N = 2**8, int busCalls = 6) {
    col witness f[busCalls];
    col witness t[busCalls];
    col witness mul[busCalls];

    col fixed L1 = [1,0...];
    col witness stage(2) gsum;
    /*
                                        muli         1
    gsum === 'gsum * (1 - L1) + ∑ᵢ ( -------- - -------- )
                                       ti + ɣ     fi + ɣ
    */

    expr LHS = 1;
    expr RHS1 = 0;
    for (int i = 0; i < busCalls; i++) {
        LHS = LHS * (t[i] + std_gamma);

        expr tmp = mul[i];
        for (int j = 0; j < busCalls; j++) {
            if (j == i) continue;
            tmp = tmp * (t[j] + std_gamma);
        }
        RHS1 = RHS1 + tmp;
    }

    expr RHS2a = LHS;
    expr RHS2b = 0;
    for (int i = 0; i < busCalls; i = i + 1) {
        LHS = LHS * (f[i] + std_gamma);
        RHS1 = RHS1 * (f[i] + std_gamma);

        expr tmp = 1;
        for (int j = 0; j < busCalls; j = j + 1) {
            if (j == i) continue;
            tmp = tmp * (f[j] + std_gamma);
        }
        RHS2b = RHS2b + tmp;
    }

    expr RHS2 = RHS2a * RHS2b;
    expr RHS = RHS1 - RHS2;

    (gsum - 'gsum * (1 - L1)) * LHS === RHS;
}


airtemplate IntermediatesIm(int N = 2**8, int busCalls = 6, int nTerms = 2) {
    assert(busCalls%nTerms == 0);

    const int nIm = busCalls/nTerms;

    col witness f[busCalls];
    col witness t[busCalls];
    col witness mul[busCalls];

    col witness stage(2) im[2*nIm];

    col fixed L1 = [1,0...];
    col witness stage(2) gsum;

    expr posIms = 0;
    expr negIms = 0;
    for (int i = 0; i < nIm; i++) {

        //              mul[i]          mul[i+1]
        // im[i] = --------------- + -----------------
        //            t[2*i] + ɣ        t[2*i+1] + ɣ

        //                   1                  1
        // im[nIm+i] = --------------- + -----------------
        //               f[2*i] + ɣ        f[2*i+1] + ɣ
        expr tProds = 1;
        expr fProds = 1;
        expr tSums = 0;
        expr fSums = 0;
        for (int j = 0; j < nTerms; j++) {
            tProds = tProds * (t[nTerms * i + j] + std_gamma);
            fProds = fProds * (f[nTerms * i + j] + std_gamma);

            tSums = tSums + mul[j]*(t[nTerms * i + j] + std_gamma);
            fSums = fSums + (f[nTerms * i + j] + std_gamma);
        }
        // im[i] * t[2*i] * t[2*i+1] === mul[i]*t[2*i+1] + mul[i+1]*t[2*i];
        im[i] * tProds === tSums;
        im[nIm+i] * fProds === fSums;

        posIms += im[i];
        negIms += im[nIm+i];
    }
    gsum === 'gsum * (1 - L1) + posIms - negIms;
}

airgroup Intermediates {
    init_challenges();

    // Intermediates(busCalls: 2);
    IntermediatesIm(busCalls: 2);

    // Intermediatesim(busCalls: 8);
    // Intermediatesim(busCalls: 8, ps: 4);

    // Intermediates(busCalls: 16);
    // Intermediatesim(busCalls: 16);
    // Intermediatesim(busCalls: 16, ps: 4);

    // Intermediates(busCalls: 24);
    // Intermediatesim(busCalls: 24, ps: 1);
    // Intermediatesim(busCalls: 24);
    // Intermediatesim(busCalls: 24, ps: 4);
}