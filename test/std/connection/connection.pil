require "goldilocks.pil"
require "gl_groups_small.pil";
// require "gl_groups_big.pil";

require "std_connection.pil";

const int TEST_OPID = 44;

// TODO: Finish Connection2 and Connection3, compute examples of permutations
// TODO: Add examples combining both approaches

air aggregate Connection1(const int N = 2**3) {
    if (N != 2**3) error(`Unsupported N = ${N}`);

    col witness a,b,c;

    const int k = Goldilocks_k;
    const int k2 = Goldilocks_k**2;
    col fixed S1,S2,S3;
    for (int i = 0; i < N; i++) {
        S1[i] = GROUP3[i];
        S2[i] = k * GROUP3[i];
        S3[i] = k2 * GROUP3[i];
    }

    // Trivial case: permutation is the identity

    // Old Interface
    connection(TEST_OPID, [a, b, c], [S1, S2, S3]);
};

air aggregate Connection2(const int N = 2**4) {
    if (N != 2**4) error(`Unsupported N = ${N}`);

    col witness a,b,c;

    const int k = Goldilocks_k;
    const int k2 = Goldilocks_k**2;
    col fixed S1,S2,S3;
    for (int i = 0; i < N; i++) {
        S1[i] = GROUP4[i];
        S2[i] = k * GROUP4[i];
        S3[i] = k2 * GROUP4[i];
    }

    // 1] Shift elements of the same column
    int tmp = S1[0];
    S1[0] = S1[1];
    S1[1] = tmp;

    // Old Interface
    connection(TEST_OPID, [a, b, c], [S1, S2, S3]);
};

air aggregate Connection3(const int N = 2**12) {
    if (N != 2**12) error(`Unsupported N = ${N}`);

    col witness a,b,c;

    const int k = Goldilocks_k;
    const int k2 = Goldilocks_k**2;
    col fixed S1,S2,S3;
    for (int i = 0; i < N; i++) {
        S1[i] = GROUP12[i];
        S2[i] = k * GROUP12[i];
        S3[i] = k2 * GROUP12[i];
    }

    // Old Interface
    connection(TEST_OPID, [a, b, c], [S1, S2, S3]);
};

air aggregate ConnectionNew(const int N = 2**4) {

    const int OPID[5] = [2,3,4,5,6];

    col witness a[5];
    col witness b[5];
    col witness c[5];
    col witness d[5];

    expr row[2][4];

    // Trivial case: do nothing
    connection_init(OPID[0], [a[0], b[0], c[0]]);
    connection_connect(OPID[0]);

    connection_init(OPID[1], [a[1], b[1], c[1]]);
    connection_update_one_cell(OPID[1], [c[1],1,c[1],1], N/2);
    connection_update_one_cell(OPID[1], [c[1],2,c[1],3], N/2);
    connection_connect(OPID[1]);

    connection_init(OPID[2], [a[2], b[2], c[2]]);
    connection_update_one_cell(OPID[2], [c[2],1,a[2],2], N/2);
    row[0] = [b[2],3,c[2],0];
    row[1] = [a[2],1,c[2],0];
    connection_update_one_cell_batch(OPID[2], row, N/2);
    connection_connect(OPID[2]);

    connection_init(OPID[3], [a[3], b[3], c[3], d[3]]);
    row[0] = [b[3],1,d[3],1];
    row[1] = [a[3],3,b[3],2];
    connection_update_one_cell_batch(OPID[3], row, N/2);
    row[0] = [c[3],2,a[3],1];
    row[1] = [c[3],3,b[3],2];
    connection_update_one_cell_batch(OPID[3], row, N/2);
    connection_connect(OPID[3]);

    connection_init(OPID[4], [a[4], b[4], c[4], d[4]]);
    connection_update_multiple_cells(OPID[4], [d[4],2,d[4],3,b[4],0], N/2);
    connection_connect(OPID[4]);
};

Connection1();
// Connection2();
// Connection3();
ConnectionNew();