require "goldilocks.pil"
require "gl_groups_small.pil";
// require "gl_groups_big.pil";

require "std_connection.pil";

const int TEST_OPID = 44;

// TODO: Finish Connection2 and Connection3, compute examples of permutations
// TODO: Add examples combining both approaches

airtemplate Connection1(const int N = 2**3) {
    if (N != 2**3) error(`Unsupported N = ${N}`);

    col witness a,b,c;

    const int k = Goldilocks_k;
    const int k2 = Goldilocks_k**2;
    col fixed S1,S2,S3;
    for (int i = 0; i < N; i++) {
        S1[i] = GROUP3[i];
        S2[i] = k * GROUP3[i];
        S3[i] = k2 * GROUP3[i];
    }

    // Trivial case: permutation is the identity

    // Old Interface
    connection(TEST_OPID, [a, b, c], [S1, S2, S3]);
};

airtemplate Connection2(const int N = 2**4) {
    if (N != 2**4) error(`Unsupported N = ${N}`);

    col witness a,b,c;

    const int k = Goldilocks_k;
    const int k2 = Goldilocks_k**2;
    col fixed S1,S2,S3;
    for (int i = 0; i < N; i++) {
        S1[i] = GROUP4[i];
        S2[i] = k * GROUP4[i];
        S3[i] = k2 * GROUP4[i];
    }

    // 1] Connect elements of the same column
    int tmp = S1[0];
    S1[0] = S1[1];
    S1[1] = tmp;

    // Old Interface
    connection(TEST_OPID, [a, b, c], [S1, S2, S3]);
};

airtemplate Connection3(const int N = 2**12) {
    if (N != 2**12) error(`Unsupported N = ${N}`);

    col witness a,b,c;

    const int k = Goldilocks_k;
    const int k2 = Goldilocks_k**2;
    col fixed S1,S2,S3;
    for (int i = 0; i < N; i++) {
        S1[i] = GROUP12[i];
        S2[i] = k * GROUP12[i];
        S3[i] = k2 * GROUP12[i];
    }

    // TODO!!!

    // Old Interface
    connection(TEST_OPID, [a, b, c], [S1, S2, S3]);
};

airtemplate ConnectionNew(const int N = 2**4) {

    const int OPID[6] = [2,3,4,5,6,7];

    col witness a[5];
    col witness b[5];
    col witness c[5];
    col witness d[5];

    expr row[2][4];

    // Trivial case: do nothing
    connection_init(OPID[0], [a[0], b[0], c[0]]);
    connection_connect(OPID[0]);

    connection_init(OPID[1], [a[1], b[1], c[1]]);
    connection_update_one_cell(OPID[1], [c[1],1,c[1],1]);
    connection_update_one_cell(OPID[1], [c[1],2,c[1],3], N/2);
    connection_connect(OPID[1]);

    connection_init(OPID[2], [a[1], b[1], c[1]], N/2);
    connection_update_one_cell(OPID[2], [c[1],1,c[1],1]);
    connection_update_one_cell(OPID[2], [c[1],2,c[1],3], N/4);
    row[0] = [a[1],1,a[1],0];
    row[1] = [c[1],2,b[1],3];
    connection_update_one_cell_batch(OPID[2], row);
    connection_update_one_cell_batch(OPID[2], row, N/4);
    connection_update_multiple_cells(OPID[2], [a[1],0,c[1],3,a[1],7]);
    connection_update_multiple_cells(OPID[2], [c[1],1,b[1],1,a[1],3], N/4);
    connection_connect(OPID[2]);

    connection_init(OPID[3], [a[2], b[2], c[2]]);
    connection_update_one_cell(OPID[3], [c[2],1,a[2],2], N/2);
    row[0] = [b[2],3,c[2],0];
    row[1] = [a[2],1,c[2],0];
    connection_update_one_cell_batch(OPID[3], row);
    connection_connect(OPID[3]);

    connection_init(OPID[4], [a[3], b[3], c[3], d[3]]);
    row[0] = [b[3],1,d[3],1];
    row[1] = [a[3],3,b[3],2];
    connection_update_one_cell_batch(OPID[4], row, N/2);
    row[0] = [c[3],2,a[3],1];
    row[1] = [c[3],3,b[3],2];
    connection_update_one_cell_batch(OPID[4], row, N/2);
    connection_connect(OPID[4]);

    connection_init(OPID[5], [a[4], b[4], c[4], d[4]]);
    connection_update_multiple_cells(OPID[5], [b[4],5,a[4],1,c[4],8]);
    connection_update_multiple_cells(OPID[5], [d[4],2,d[4],3,b[4],0], N/2);
    connection_connect(OPID[5]);
};

// TODO: Remove this airgroup and uncomment the original idea that follows commented below
airgroup Connection {
    Connection1();
    Connection2();
    // Connection3();
    // ConnectionNew();
}

// airgroup Connection1 {
//     Connection1();
// }
// airgroup Connection2 {
//     Connection2();
// }
// airgroup Connection3 {
//     Connection3();
// }
// airgroup ConnectionNew {
//     ConnectionNew();
// }