include "module.pil";

constant MAIN_ID = 1;
constant BINARY_ID = 2;
constant ARITH_ID = 3;
constant MEM_ID = 4;

challenge stage(2) std_alpha;
challenge stage(2) std_beta;

public mod;
public in1;
public in2;
public out;

function final_function() {
    gsum_main + gsum_module === 0;
}

subproof aggregate Main(2**10) {

    subproofval aggregate(sum) gsum_main;

    col fixed L1 = [1,0...];
    col witness a,b;

    (b' - a) * (1 - L1') === 0;
    L1 * (b - in1) === 0;
    L1 * (a - in2) === 0;

    col witness stage(2) gsum;

    @gsum { reference: gsum, numerator: 5, denominator: ((((L1'2*out + (1 - L1'2)*a') * std_alpha + a * a + b * b) * std_alpha) + MODULE_ID + std_beta)}

    @subproofvalue { reference: gsum_fibonacci, expression: gsum, row_index: N - 1 }

    (gsum - 'gsum * (1 - L1)) * ((((L1'2*out + (1 - L1'2)*a') * std_alpha + a * a + b * b) * std_alpha) + MODULE_ID + std_beta) + 1 === 0;
    L1' * (gsum - gsum_fibonacci) === 0;

    on final proof final_function();
};

subproof Module(2**4) {

    subproofval aggregate(sum) gsum_module;

    col fixed L1 = [1,0...];
    col witness x, q, x_mod;

    // TODO: verify range checks and x_mod < mod
    x === q * mod + x_mod;

    col witness stage(2) gsum;

    @gsum { reference: gsum, numerator: 1, denominator: (((x_mod * std_alpha + x) * std_alpha) + MODULE_ID + std_beta)}

    @subproofvalue { reference: gsum_module, expression: gsum, row_index: N - 1 }

    (gsum - 'gsum * (1 - L1)) * (((x_mod * std_alpha + x) * std_alpha) + MODULE_ID + std_beta) - 1 === 0;

    L1' * (gsum - gsum_module) === 0;
}
