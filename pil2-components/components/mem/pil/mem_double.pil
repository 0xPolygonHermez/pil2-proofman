const int MEM_ID = 4;

subproof Mem(2**16) {

    col fixed INCS = [1,2..N];
    col fixed LLAST = [0...,1];
    const expr IS_NOT_LAST = (1 - LLAST);
    const int MAX_STEP = 2**23;

    // single: 13 cols
    // double: 15 cols <== safe area if more than 26.7% of memory access are R-R,W-R for same addr and value
    // for example: with 80% => double = 60% * single (safe 40% of area)

    col witness addr;
    col witness step[2];
    col witness sel, wr;
    col witness value[8];
    col witness isDouble;
    col witness lastAccess; // 1 if its the last access of a given address

    // The list is sorted by [addr, step]
    lastAccess * (1 - lastAccess) === 0;
    isDouble * (1 - isDouble) === 0;
    isDouble * (1 - sel) === 0;

    const expr stepDelta = step[0]' + isDouble * (step[0] - step[1]) - step[0];

    range_check(IS_NOT_LAST, lastAccess * (addr' - addr - stepDelta) + stepDelta, 1, MAX_STEP);
    range_check(isDouble, step[1] - step[0], 1, MAX_STEP);


    // ISNOTLAST { lastAccess * (addr' - addr - (step'-step)) + (step'-step) } ;
    (1 - lastAccess) * (addr' - addr) === 0;

    sel * (1 - sel) === 0;
    wr * (1 - wr) === 0;
    // wr could be 1 only if sel is 1
    (1 - sel) * wr === 0;

    // const expr isWrite = sel' * wr';
    const expr rdSame = (1 - wr) * (1-lastAccess);
    const expr rdDifferent = (1 - wr) * lastAccess;

    // lastAccess has to be 1 in the last evaluation. This is necessary to
    // validate [rdDifferent * (val[0]') = 0;] correctly (in a cyclic way)
    (lastAccess - 1) * (1 - IS_NOT_LAST) === 0;

    for (int index = 0; index < length(value); index = index + 1) {
        rdSame * (value[index]' - value[index])  ===  0;
        rdDifferent * value[index]'  ===  0;
    }

    multiset_proves(MEM_ID, sel, [addr, step[0], wr, ...value]);

    // only allowed double operations: R R or W R (always same addr and value)
    // second operation always is a read
    multiset_proves(MEM_ID, isDouble, [addr, step[1], 0, ...value]);
}