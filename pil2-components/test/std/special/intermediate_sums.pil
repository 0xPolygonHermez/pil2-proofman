require "std_constants.pil";
require "std_sum.pil";

/*
    Constraint to optimize:
                               NUMᵢ
                L === R + ∑ᵢ ------
                               DENᵢ
    Where:
        · L is an expression of degree 1 and R is an expression of degree 2.
        · NUMᵢ and DENᵢ are expressions, not necessarily equal, of any degree greater or equal than 0.

    To audit and generate stats:
    node ../pil2-compiler/src/pil.js ./pil2-components/test/std/special/intermediate_sums.pil -I ./pil2-components/lib/std/pil -o ./pil2-components/test/std/special/build/intermediate_sums.pilout
    node --max-old-space-size=131072 ../pil2-compiler/tools/audit.js pil2-components/test/std/special/build/intermediate_sums.pilout
    node --max-old-space-size=131072 ../pil2-proofman-js/src/main_stats.js -a pil2-components/test/std/special/build/intermediate_sums.pilout -o pil2-components/test/std/special/build/intermediate_sums.stats
*/

airtemplate ImDummy(const int N = 2**8, const int degs_num[], const int degs_den[]) {
    const int M = length(degs_num);
    assert((M > 0) && (M == length(degs_den)));
    int deg_num_sum = 0;
    int deg_den_sum = 0;
    for (int i = 0; i < M; i++) {
        deg_num_sum += degs_num[i];
        deg_den_sum += degs_den[i];
    }
    assert((deg_num_sum > 0) || (deg_den_sum > 0));

    sum_set_expressions_im_non_reduced(-1); // Don't apply any reduction

    // Enlarge the degree of the numerator
    col witness num[M];
    expr NUM[M] = increase_degree(num, degs_num, 0);

    // Enlarge the degree of the denominator
    col witness den[M];
    expr DEN[M] = increase_degree(den, degs_den, 1);

    string description = "Degrees Visualization: ";
    for (int i = 0; i < M; i++) {
        if (i == M-1) {
            description += `${degree(NUM[i])}/${degree(DEN[i])}`;
        } else {
            description += `${degree(NUM[i])}/${degree(DEN[i])} + `;
        }
        sum(PIOP_NAME_ISOLATED, SUM_TYPE_FREE, [0], 0, [DEN[i]], NUM[i])
    }
    println(description);
}

airtemplate ImCustom(const int N = 2**8, const int degs_num[], const int degs_den[]) {
    const int M = length(degs_num);
    assert((M > 0) && (M == length(degs_den)));
    int deg_num_sum = 0;
    int deg_den_sum = 0;
    for (int i = 0; i < M; i++) {
        deg_num_sum += degs_num[i];
        deg_den_sum += degs_den[i];
    }
    assert((deg_num_sum > 0) || (deg_den_sum > 0));

    sum_set_expressions_im_non_reduced(0); // Apply all the reductions

    // Enlarge the degree of the numerator
    col witness num[M];
    expr NUM[M] = increase_degree(num, degs_num, 0);

    // Enlarge the degree of the denominator
    col witness den[M];
    expr DEN[M] = increase_degree(den, degs_den, 1);

    string description = "Degrees Visualization: ";
    for (int i = 0; i < M; i++) {
        if (i == M-1) {
            description += `${degree(NUM[i])}/${degree(DEN[i])}`;
        } else {
            description += `${degree(NUM[i])}/${degree(DEN[i])} + `;
        }
        sum(PIOP_NAME_ISOLATED, SUM_TYPE_FREE, [0], 0, [DEN[i]], NUM[i])
    }
    println(description);
}

function increase_degree(const expr exps[], const int deg[], const int type): expr[] {
    const int M = length(exps);
    expr result[M];
    for (int i = 0; i < M; i++) {
        const int d = deg[i];
        if (d == 0) {
            result[i] = 1;
        } else if (d == 1) {
            result[i] = exps[i];
        } else {
            result[i] = exps[i];
            const int num_extra = d-1;
            if (type == 0) {
                col witness extra_num[num_extra];
                for (int j = 0; j < num_extra; j++) {
                    result[i] *= extra_num[j];
                }
            } else {
                col witness extra_den[num_extra];
                for (int j = 0; j < num_extra; j++) {
                    result[i] *= extra_den[j];
                }
            }
        }
        assert(degree(result[i]) == d);
    }

    return result;
}

airgroup Intermediates {
    ImDummy(degs_num: [1, 0], degs_den: [0, 1]) alias ImDummy_1;
    ImCustom(degs_num: [1, 0], degs_den: [0, 1]) alias ImCustom_1;

    ImDummy(degs_num: [1, 1, 1, 1], degs_den: [1, 1, 1, 1]) alias ImDummy_2;
    ImCustom(degs_num: [1, 1, 1, 1], degs_den: [1, 1, 1, 1]) alias ImCustom_2;

    int degs_den[8];
    int degs_num[8];
    for (int i = 0; i < 8; i++) {
        degs_num[i] = 1;
        degs_den[i] = 1;
    }
    ImDummy(degs_num: degs_num, degs_den: degs_den) alias ImDummy_3;
    ImCustom(degs_num: degs_num, degs_den: degs_den) alias ImCustom_3;

    ImDummy(degs_num: [4, 2, 2, 5, 3, 2, 2, 1], degs_den: [0, 3, 1, 1, 0, 1, 2, 3]) alias ImDummy_4;
    ImCustom(degs_num: [4, 2, 2, 5, 3, 2, 2, 1], degs_den: [0, 3, 1, 1, 0, 1, 2, 3]) alias ImCustom_4;
}