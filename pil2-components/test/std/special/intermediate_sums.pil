require "std_tools.pil";

/*

Table of generated numbers, which assume a maximum expression degree of 3:

 #BusCalls | SumExp | #Cols1 |   #Cols2      | #Cols3 |  Total | #Constraints |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    1      |  Dummy |   3    | 4 (3 im)/12   |   2/6  |  12/24 |      4       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    1      |  Std   |   3    | 3 (0 im)/9    |   1/3  |  8/16  |      4       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    2      |  Dummy |   6    | 4 (3 im)/12   |   2/6  |  12/24 |      4       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    2      |  Std   |   6    | 3 (0 im)/9    |   2/6  |  11/21 |      3       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    4      |  Dummy |   12   | 13 (12 im)/39 |   2/6  |  27/57 |      13      |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    4      |  Std   |   12   | 5 (0 im)/15   |   2/6  |  19/33 |      5       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    6      |  Dummy |   18   | 31 (30 im)/93 |   2/6  | 51/117 |      31      |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    6      |  Std   |   18   | 7 (0 im)/21   |   2/6  |  27/45 |      7       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    8      |  Dummy |   24   | 57 (56 im)/171|   2/6  | 83/201 |      57      |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼
    8      |  Std   |   24   | 9 (0 im)/27   |   2/6  |  35/57 |      9       |
───────────┼────────┼────────┼───────────────┼────────┼────────┼──────────────┼

Constraint to optimize:
                               NUMi
            GL === GR + ∑ᵢ ----------
                             DENi + ɣ
    · GR is an expression of degree 2 to be as close as possible to the actual expression.
    · ɣ is a challenge added to make the denominator an extension-field expression.
*/

airtemplate ImDummy(const int N = 2**8, const int degNum = 1, const int degDen = 1, const int M = 6) {
    col witness stage(2) GL;
    col fixed L1 = [1,0...];
    expr GR = 'GL * L1;     // Just to be realistic
    assert(degree(GR) == 2);

    col witness num[M];
    expr NUM[M];
    for (int i = 0; i < M; i++) {
        NUM[i] = num[i];
        // Enlarge the degree of the numerator
        for (int j = 1; j < degNum; j++) {
            col witness _num;
            NUM[i] *= _num;
        }
        assert(degree(NUM[i]) == degNum);
    }

    col witness den[M];
    expr DEN[M];
    for (int i = 0; i < M; i++) {
        DEN[i] = den[i];
        // Enlarge the degree of the denominator
        for (int j = 1; j < degDen; j++) {
            col witness _den;
            DEN[i] *= _den;
        }
        assert(degree(DEN[i]) == degDen);
    }

    /*
      Transform the rational constraint to a polynomial one:
            (GL - GR) · ∏i (DENi + ɣ) === ∑ᵢ NUMi · ∏j≠i (DENj + ɣ)     
    */
    expr LHS = 1;
    expr RHS = 0;
    for (int i = 0; i < M; i++) {
        LHS *= (DEN[i] + std_gamma);

        expr _RHS = NUM[i];
        for (int j = 0; j < M; j++) {
            if (j == i) continue;
            _RHS *= (DEN[j] + std_gamma);
        }
        RHS += _RHS;
    }

    (GL - GR) * LHS === RHS;
}


airtemplate ImStd(const int N = 2**8, const int degNum = 1, const int degDen = 1, const int M = 6, const int clusterSize = 2) {
    col witness stage(2) GL;
    col fixed L1 = [1,0...];
    expr GR = 'GL * L1;

    col witness num[M];
    expr NUM[M];
    for (int i = 0; i < M; i++) {
        NUM[i] = num[i];
        // Enlarge the degree of the numerator
        for (int j = 1; j < degNum; j++) {
            col witness _num;
            NUM[i] *= _num;
        }
        assert(degree(NUM[i]) == degNum);
    }

    col witness den[M];
    expr DEN[M];
    for (int i = 0; i < M; i++) {
        DEN[i] = den[i];
        // Enlarge the degree of the denominator
        for (int j = 1; j < degDen; j++) {
            col witness _den;
            DEN[i] *= _den;
        }
        assert(degree(DEN[i]) == degDen);
    }

    /*
      Transform the rational constraint to a polynomial one by substituting
      all the rational terms by terms of degree 1:
            GL === GR + ∑ᵢ imi 
    */
    int low_degree_term[M];
    int high_degree_term[M];
    int low_degree_len = 0;
    int high_degree_len = 0;
    for (int i = 0; i < M; i++) {
        if (degree(NUM[i]) > 2 || degree(DEN[i]) > 1) { // TBD: Discriminator conditions
            high_degree_term[high_degree_len] = i;
            high_degree_len++;
        } else {
            low_degree_term[low_degree_len] = i;
            low_degree_len++;
        }
    }

    expr sumIms = 0;
    if (low_degree_len > 0) {
        // Group terms in clusters so that the degree of the constraint
        // is lower than the maximum allowed
        const int nIm = low_degree_len/clusterSize;

        col witness stage(2) im[nIm];

        for (int i = 0; i < nIm; i++) {
            /*
                        NUM[3*i]          NUM[3*i+1]          NUM[3*i+2]
            im[i] = --------------- + ----------------- + -----------------
                        DEN[3*i] + ɣ      DEN[3*i+1] + ɣ      DEN[3*i+2] + ɣ
            */
            expr LHS = 1;
            expr RHS = 0;
            for (int j = 0; j < clusterSize; j++) {
                LHS *= (DEN[low_degree_term[clusterSize * i + j]] + std_gamma);

                expr _partial = NUM[low_degree_term[clusterSize * i + j]];
                for (int k = 0; k < clusterSize; k++) {
                    if (k == j) continue;
                    _partial *= (DEN[low_degree_term[clusterSize * i + k]] + std_gamma);
                }
                RHS += _partial;
            }

            im[i] * LHS === RHS;

            sumIms += im[i];
        }

        const int nRemTerms = low_degree_len % clusterSize;
        if (nRemTerms != 0) {
            // If there are remaining terms, add an extra cluster
            col witness stage(2) im_extra;

            expr LHS = 1;
            expr RHS = 0;
            for (int j = 0; j < nRemTerms; j++) {
                LHS *= (DEN[low_degree_term[clusterSize * nIm + j]] + std_gamma);

                expr _partial = NUM[low_degree_term[clusterSize * nIm + j]];
                for (int k = 0; k < nRemTerms; k++) {
                    if (k == j) continue;
                    _partial *= (DEN[low_degree_term[clusterSize * nIm + k]] + std_gamma);
                }
                RHS += _partial;
            }

            im_extra * LHS === RHS;

            sumIms += im_extra;
        }
    }

    if (high_degree_len > 0) {
        // Create a single intermediate for all the high-degree terms
        /*
                       NUM[i]   
           im[i] = ---------------
                     DEN[i] + ɣ  
        */
        col witness stage(2) im_high_degree[high_degree_len];

        for (int i = 0; i < high_degree_len; i++) {
            im_high_degree[i] * (DEN[high_degree_term[i]] + std_gamma) === NUM[high_degree_term[i]];
            sumIms += im_high_degree[i];
        }
    }

    GL === GR + sumIms;
}

airgroup Intermediates {
    init_challenges();

    ImDummy(degNum: 1, degDen: 1, M: 1) alias ImDummy_1;
    ImStd(degNum: 1, degDen: 1, M: 1) alias ImStd_1;

    ImDummy(degNum: 1, degDen: 1, M: 2) alias ImDummy_2;
    ImStd(degNum: 1, degDen: 1, M: 2) alias ImStd_2;

    ImDummy(degNum: 1, degDen: 1, M: 4) alias ImDummy_4;
    ImStd(degNum: 1, degDen: 1, M: 4) alias ImStd_4;

    ImDummy(degNum: 1, degDen: 1, M: 6) alias ImDummy_6;
    ImStd(degNum: 1, degDen: 1, M: 6) alias ImStd_6;

    ImDummy(degNum: 1, degDen: 1, M: 8) alias ImDummy_8;
    ImStd(degNum: 1, degDen: 1, M: 8) alias ImStd_8;
}