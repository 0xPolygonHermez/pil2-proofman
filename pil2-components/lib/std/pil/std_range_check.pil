require "std_lookup.pil";

// With the logup protocol, it is more performant to look up to the same range;
// so we'll try to "absorb" all the introduced ranges into some of the default ranges.
// Moreover, having a fewer ranges makes the preprocessing faster and the prvoing less memory consuming

const int MAX_RANGE_LEN = (PRIME - 1) / 2;
const int STD_P2_8 = 2**8;
const int STD_BYTE = STD_P2_8-1;
const int STD_TWO_BYTES = 2**16-1;

const int DEFAULT_OPIDS[3] = [100, 101, 102];
int last_assigned_opid = DEFAULT_OPIDS[length(DEFAULT_OPIDS) - 1];

private function next_available_opid(): int {
    last_assigned_opid++;
    return last_assigned_opid;
}

private function get_opid(const int min, const int max, const int predefined): int {
    if (predefined && min >= 0) {
        if (max <= STD_BYTE) {
            return (min > 0 || max < STD_BYTE) ? DEFAULT_OPIDS[2] : DEFAULT_OPIDS[0];
        } else if (max <= STD_TWO_BYTES) {
            return DEFAULT_OPIDS[1];
        }
    }

    return next_available_opid();
}

airtemplate U8Air(const int N = 2**8) {
    if (N != 2**8) {
        error(`The number of rows N should be 2**8 to use the predefined range U8, got N=${N} instead`);
    }

    // save the airgroup id and air id of the table for latter use
    proof.std.u8.airgroup_id = AIRGROUP_ID;
    proof.std.u8.air_id = AIR_ID;

    col witness mul;

    @u8air{reference: mul};

    col fixed U8 = [0..STD_BYTE];
    lookup_proves(DEFAULT_OPIDS[0], [U8], mul, PIOP_NAME_RANGE_CHECK);
}

airtemplate U8AirExtended(const int N = 2**16) {
    // The same as U8Air, but with the cartisian product of U8 with itself to allow for lookups from two to two

    if (N != 2**16) {
        error(`The number of rows N should be 2**16 to use the predefined range U8xU8, got N=${N} instead`);
    }

    // save the airgroup id and air id of the table for latter use
    proof.std.u8ext.airgroup_id = AIRGROUP_ID;
    proof.std.u8ext.air_id = AIR_ID;

    col witness mul;

    @u8airext{reference: mul};

    col fixed U8_A = [0..STD_BYTE]...;
    col fixed U8_B = [0:STD_P2_8..STD_BYTE:STD_P2_8];
    lookup_proves(DEFAULT_OPIDS[2], [U8_A, U8_B], mul, PIOP_NAME_RANGE_CHECK);
}

airtemplate U16Air(const int N = 2**16) {
    if (N != 2**16) {
        error(`The number of rows N should be 2**16 to use the predefined range U16, got N=${N} instead`);
    }

    // save the airgroup id and air id of the table for latter use
    proof.std.u16.airgroup_id = AIRGROUP_ID;
    proof.std.u16.air_id = AIR_ID;

    col witness mul;

    @u16air{reference: mul};

    col fixed U16 = [0..STD_TWO_BYTES];
    lookup_proves(DEFAULT_OPIDS[1], [U16], mul, PIOP_NAME_RANGE_CHECK);
}

airtemplate SpecifiedRanges(const int N, const int opids[], const int opids_count, const int predefineds[], const int mins[], const int maxs[]) {
    // save the airgroup id and air id of the table for latter use
    proof.std.specified.airgroup_id = AIRGROUP_ID;
    proof.std.specified.air_id = AIR_ID;

    @specified_ranges{num_rows: N};

    col witness mul[opids_count];

    for (int j = 0; j < opids_count; j++) {
        int opid = opids[j];
        int predefined = predefineds[j];
        int min = mins[j];
        int max = maxs[j];

        @specified_ranges{reference: mul[j], predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0};

        if (N < max - min + 1) {
            error(`The range [min,max]=[${min},${max}] is too big, the maximum range length is ${N}`);
        }

        col fixed RANGE = [min..max-1,max...];
        lookup_proves(opid, [RANGE], mul[j], PIOP_NAME_RANGE_CHECK);
    }
}

// Three user interfaces

// 1] Interface where the user directly calls the range check over a column and a range

/**
 * TODO: Add description
 */
function range_check(expr colu, int min, int max, expr sel = 1, int predefined = 1) {
    range_validator(min, max);

    @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0};

    if (min < 0) {
        println(`The provided min=${min} is negative. Falling back to specified range...`);
    } else if (max > STD_TWO_BYTES) {
        println(`The provided max=${max} is greater than the maximum predefined ${STD_TWO_BYTES}. Falling back to specified range...`);
    }

    const int opid = opid_process(min, max, predefined);

    // Check if the range can be absorbed into the predefined ranges
    const int absorb = predefined && min >= 0 && max <= STD_TWO_BYTES;

    // Define the assume
    if (absorb) {
        if (min == 0) {
            if (max == STD_BYTE) {
                // Here, we should decide whether to use the U8 or the U8xU8 table, using the latter by default to optimize the number of lookups
                container air.std.rc.u8ext alias rc_u8ext {
                    int rc_u8ext_ncols = 0;
                    expr rc_u8ext_cols[100];
                    expr rc_u8ext_sels[100];
                }

                rc_u8ext.rc_u8ext_cols[rc_u8ext.rc_u8ext_ncols] = colu;
                rc_u8ext.rc_u8ext_sels[rc_u8ext.rc_u8ext_ncols] = sel;
                rc_u8ext.rc_u8ext_ncols++;

                on final air define_assumes_u8ext();
                return;
            } else if (max == STD_TWO_BYTES) {
                airgroup.std.rc.u16_used = 1;

                lookup_assumes(opid, [colu], sel, PIOP_NAME_RANGE_CHECK);
            }
        } else {
            if (max <= STD_BYTE) {
                // Here, the range is of the form [a,b], with a >= 0 and b <= STD_BYTE, except for the range [0,STD_BYTE]

                // To avoid two lookups, we use the U8xU8 air
                airgroup.std.rc.u8ext_used = 1;

                // colu is in [a,b] iff colu-min is in [0,STD_BYTE] and max-colu is in [0,STD_BYTE]
                // iff [colu-min,max-colu] is in [0,STD_BYTE]x[0,STD_BYTE]
                lookup_assumes(opid, [colu - min, max - colu], sel, PIOP_NAME_RANGE_CHECK);
            } else if (max <= STD_TWO_BYTES) {
                // Here, the range is of the form [a,b], with a >= 0 and STD_BYTE < b <= STD_TWO_BYTES, except for the range [0,STD_TWO_BYTES]

                // reuse U16
                airgroup.std.rc.u16_used = 1;

                // first prove that colu - min is in U16
                lookup_assumes(opid, [colu - min], sel, PIOP_NAME_RANGE_CHECK);

                // second prove that max - colu is in U16
                lookup_assumes(opid, [max - colu], sel, PIOP_NAME_RANGE_CHECK);
            }
        }
    } else {
        lookup_assumes(opid, [colu], sel, PIOP_NAME_RANGE_CHECK);
    }

    // Define the prove
    define_proves(absorb);
}

/**
 * TODO: Add description
 */
function range_check_group(const expr cols[], const int min, const int max, const expr sels[], const int predefined = 1) {
    const int len = length(cols);
    if (len != length(sels)) {
        error(`The length of cols (${len}) and sels (${length(sels)}) should be the same`);
    }

    for (int i = 0; i < length(cols); i++) {
        range_check(cols[i], min, max, sels[i], predefined);
    }
}

// 2] Interface where the user can perform a range check over two ranges based on a selector

/**
 * TODO: Add description
 * TODO: Generalize to more than 2 ranges
 * If range_sel = 1, then the range [min1,max1] is checked, otherwise [min2,max2]
 */
function multi_range_check(expr colu, int min1, int max1, int min2, int max2, expr range_sel = 1, expr sel = 1, int predefined = 0): int {
    if (predefined) {
        error(`WIP: Multi range check cannot be predefined`);
    }

    if (min1 == min2 && max1 == max2) {
        error(`The ranges defined in the multi range check are the same: [${min1},${max1}]`);
    }

    range_validator(min1, max1);
    range_validator(min2, max2);

    @range_def{predefined: predefined, min: min1, max: max1, min_neg: min1 < 0 , max_neg: max1 < 0};
    @range_def{predefined: predefined, min: min2, max: max2, min_neg: min2 < 0 , max_neg: max2 < 0};

    const int opid1 = opid_process(min1, max1, predefined);
    const int opid2 = opid_process(min2, max2, predefined);

    // Define the assume
    lookup_assumes_dynamic([opid1,opid2], range_sel*(opid1-opid2) + opid2, [colu], sel, PIOP_NAME_RANGE_CHECK);

    // Define the prove
    define_proves(absorb: 0);

    // Note: This solution improves the naive solution:
    //   · range_check(colu, min1, max1, 0, sel*range_sel).
    //   · range_check(colu, min2, max2, 0, sel*(1-range_sel)).
    // by just performing 1 assume and 2 proves instead
    //
    // Q: Can I do it with 1 assume and 1 prove? E.g.:
    // lookup_assumes_dynamic([opid1,opid2], range_sel*(opid1-opid2) - opid2, [colu], sel, PIOP_NAME_RANGE_CHECK);
    // lookup_proves(opid, [min1..max1-1,max1...]U[min2..max2-1,max2...], mul, PIOP_NAME_RANGE_CHECK);
}

// 3] Interface where the user can first get the range check id:
//      int id_range_24 = range_check_id(0, 2**24-1);
//      int id_range_16 = range_check_id(0, 2**16-1);
//      int id_range_15 = range_check_id(0, 2**15-1);
//    and then perform the range check using a user-defined range selector:
//      col witness sel_8, sel_16, sel_32;
//      range_check_dynamic(colu, id_range_24 * sel_8 + id_range_16 * sel_16 + id_range_15 * sel_32);

function range_check_id(const int min, const int max, const int predefined = 0): int {
    if (predefined) {
        error(`WIP: Range check id cannot be predefined`);
    }

    range_validator(min, max);

    @range_def{predefined: predefined, min: min, max: max, min_neg: min < 0, max_neg: max < 0};

    container air.std.rcid alias rcid {
        int opids_count_id = 0;
        int opids_id[100];
        int called = 0;
    }

    const int opid = opid_process(min, max, predefined);

    // Save the opid for use in the dynamic range check
    rcid.opids_id[rcid.opids_count_id] = opid;
    rcid.opids_count_id++;

    // At the end of the air, check if dynamic range checks were called
    on final air check_dynamic_called();

    return opid;
}

function range_check_dynamic(const expr colu, const expr range_sel, const expr sel = 1) {
    use air.std.rcid;

    // Mark the dynamic range check as called
    called = 1;

    int opids[opids_count_id];
    for (int i = 0; i < opids_count_id; i++) {
        opids[i] = opids_id[i];
    }

    // Define the assume
    lookup_assumes_dynamic(opids, range_sel, [colu], sel, PIOP_NAME_RANGE_CHECK);

    // Define the prove
    define_proves(absorb: 0);
}

// Private functions
private function check_dynamic_called() {
    use air.std.rcid;
    if (!called) {
        error(`Dynamic range check was not called`);
    }
}

private function range_validator(const int min, const int max) {
    if (min > max) {
        error(`min = ${min} cannot be greater than max = ${max}`);
    } else if (min == max) {
        error(`Min and max are the same, you should use a single value check instead: colu === ${min}`);
    } else if (max - min + 1 < 8) { // The 8 was chosen comparing the cost of logup vs the cost of a multiple value check
        const int diff = max - min + 1;

        string diff_str = `(colu - ${min})`;
        for (int i = 1; i < diff; i++) {
            diff_str = diff_str + `·(colu - ${min + i})`;
        }

        println(`The range [${min}..${max}] is too small, consider using a multiple value check instead: ${diff_str} === 0`);
    } else if (max - min + 1 > MAX_RANGE_LEN) {
        error(`The range [${min}..${max}] is too big, the maximum range length is (PRIME - 1) / 2 = ${MAX_RANGE_LEN}`);
    } else if (max >= PRIME) {
        error(`The maximum value of the range cannot be greater than the field order ${PRIME}`);
    } else if (min <= -PRIME) {
        error(`The minimum value of the range cannot be less than the negative field order ${-PRIME}`);
    }
}

private function opid_process(const int min, const int max, const int predefined): int {
    container proof.std.rc alias rcproof {
        // Number of times defined range airs are used
        int num_u8_airgroup = 0;
        int num_u8ext_airgroup = 0;
        int num_u16_airgroup = 0;
        int num_spec_airgroup = 0;

        // Last airgroup id that defined range airs used
        int max_u8_airgroup_id = 0;
        int max_u8ext_airgroup_id = 0;
        int max_u16_airgroup_id = 0;
        int max_spec_airgroup_id = 0;

        // N to be used in the specified ranges air
        int specified_N = 0;

        // FIX: dynamic arrays not ready
        int opids_count = 0;
        int opids[100];
        int predefineds[100];
        int mins[100];
        int maxs[100];
    }

    container airgroup.std.rc {
        // To mark if the U8 and U16 airs are used within the airgroup
        int u8_used = 0;
        int u8ext_used = 0;
        int u16_used = 0;
    }

    // If the range has already been introduced, we reuse the same opid
    for (int i = 0; i < rcproof.opids_count; i++) {
        if (predefined == rcproof.predefineds[i] && min == rcproof.mins[i] && max == rcproof.maxs[i]) {
            return rcproof.opids[i];
        }
    }

    // Otherwise, we get the corresponding opid
    const int opid = get_opid(min, max, predefined);

    // Exit if the range does not belong to the specified ranges air
    if (opid <= DEFAULT_OPIDS[length(DEFAULT_OPIDS) - 1]) {
        return opid;
    }

    // Save range data for later use in the specified ranges air
    rcproof.predefineds[rcproof.opids_count] = predefined;
    rcproof.mins[rcproof.opids_count] = min;
    rcproof.maxs[rcproof.opids_count] = max;
    rcproof.opids[rcproof.opids_count] = opid;
    rcproof.opids_count++;

    // if the opid is not predefined and the range is bigger than the current specified_N, we update it
    if (opid > DEFAULT_OPIDS[length(DEFAULT_OPIDS) - 1] && max - min > rcproof.specified_N) {
        rcproof.specified_N = max - min;
    }

    return opid;
}

private function define_assumes_u8ext() {
    use air.std.rc.u8ext;

    if (rc_u8ext_ncols == 1) {
        // If there is only one column, we use the U8 air
        airgroup.std.rc.u8_used = 1;

        lookup_assumes(DEFAULT_OPIDS[0], [rc_u8ext_cols[0]], rc_u8ext_sels[0], PIOP_NAME_RANGE_CHECK);
    } else if (rc_u8ext_ncols > 1) {
        // If there are more than one column, we use the U8xU8 air
        airgroup.std.rc.u8ext_used = 1;

        for (int i = 0; i < rc_u8ext_ncols; i += 2) {
            lookup_assumes(DEFAULT_OPIDS[2], [rc_u8ext_cols[i], rc_u8ext_cols[i+1]], rc_u8ext_sels[i]*rc_u8ext_sels[i+1], PIOP_NAME_RANGE_CHECK);
        }

        const int rem_cols = rc_u8ext_ncols % 2;
        if (rem_cols == 1) {
            lookup_assumes(DEFAULT_OPIDS[2], [rc_u8ext_cols[rc_u8ext_ncols-1], 0], rc_u8ext_sels[rc_u8ext_ncols-1], PIOP_NAME_RANGE_CHECK);
        }
    }

    define_proves(absorb: 1);
}

private function define_proves(const int absorb) {
    use proof.std.rc;

    if (absorb) {
        // If the U8 was used, update the max airgroup id
        if (airgroup.std.rc.u8_used) {
            if (max_u8_airgroup_id < AIRGROUP_ID) {
                max_u8_airgroup_id = AIRGROUP_ID;
            }
        }

        // If the U8Ext was used, update the max airgroup id
        if (airgroup.std.rc.u8ext_used) {
            if (max_u8ext_airgroup_id < AIRGROUP_ID) {
                max_u8ext_airgroup_id = AIRGROUP_ID;
            }
        }

        // If the U16 was used, update the max airgroup id
        if (airgroup.std.rc.u16_used) {
            if (proof.std.rc.max_u16_airgroup_id < AIRGROUP_ID) {
                proof.std.rc.max_u16_airgroup_id = AIRGROUP_ID;
            }
        }

        on final airgroup declarePreRangeAir();
        on final proof createPreMetadata();
    } else {
        // If the specified range is used, update the max airgroup id
        if (max_spec_airgroup_id < AIRGROUP_ID) {
            max_spec_airgroup_id = AIRGROUP_ID;
        }

        on final airgroup declareRangeAir();
        on final proof createMetadata();
    }
}

private function declarePreRangeAir() {
    use proof.std.rc;

    // If the U8 was used in the airgroup, update the number of U8 airgroups
    if (airgroup.std.rc.u8_used) {
        num_u8_airgroup++;
    }

    // If the U8Ext was used in the airgroup, update the number of U8Ext airgroups
    if (airgroup.std.rc.u8ext_used) {
        num_u8ext_airgroup++;
    }

    // If the U16 was used in the airgroup, update the number of U16 airgroups
    if (airgroup.std.rc.u16_used) {
        num_u16_airgroup++;
    }

    // The U8, U8ext and U16 airs are only needed once, so we wait for the last airgroup that uses them
    if (
        AIRGROUP_ID != max_u8_airgroup_id    && 
        AIRGROUP_ID != max_u8ext_airgroup_id && 
        AIRGROUP_ID != max_u16_airgroup_id
    ) {
        return;
    }

    if (AIRGROUP_ID == max_u8_airgroup_id && num_u8_airgroup > 0) {
        // container used to store the airgroup id and air id of the table
        container proof.std.u8 {
            int airgroup_id = 0;
            int air_id = 0;
        }

        if (num_u8_airgroup == 1){
            // If the U8Air is needed only once, we instantiate it in the (single) callable airgroup
            U8Air();
        } else {
            // If the U8Air is needed more than once, we instantiate it in its own airgroup
            airgroup U8Air {
                U8Air();
            }
        }
    }

    if (AIRGROUP_ID == max_u8ext_airgroup_id && num_u8ext_airgroup > 0) {
        container proof.std.u8ext {
            int airgroup_id = 0;
            int air_id = 0;
        }

        if (num_u8ext_airgroup == 1){
            // If the U8AirExtended is needed only once, we instantiate it in the (single) callable airgroup
            U8AirExtended();
        } else {
            // If the U8AirExtended is needed more than once, we instantiate it in its own airgroup
            airgroup U8AirExtended {
                U8AirExtended();
            }
        }
    }

    if (AIRGROUP_ID == max_u16_airgroup_id && num_u16_airgroup > 0) {
        container proof.std.u16 {
            int airgroup_id = 0;
            int air_id = 0;
        }

        if (num_u16_airgroup == 1){
            // If the U16Air is needed only once, we instantiate it in the (single) callable airgroup
            U16Air();
        } else {
            // If the U16Air is needed more than once, we instantiate it in its own airgroup
            airgroup U16Air {
                U16Air();
            }
        }
    }
}

private function declareRangeAir() {
    container proof.std.specified {
        int airgroup_id = 0;
        int air_id = 0;
    }

    use proof.std.rc;

    // Update the number of specified ranges airgroups
    num_spec_airgroup++;

    // The specified ranges air is only needed once, so we wait for the last airgroup that uses them
    if (AIRGROUP_ID != max_spec_airgroup_id) {
        return;
    }

    const int next_pow2 = 2**(log2(specified_N));

    if (num_spec_airgroup == 1) {
        // If the SpecifiedRanges is needed only once, we instantiate it in the (single) callable airgroup
        SpecifiedRanges(next_pow2, opids, opids_count, predefineds, mins, maxs);
    } else {
        // If the SpecifiedRanges is needed more than once, we instantiate it in its own airgroup
        airgroup SpecifiedRanges {
            SpecifiedRanges(next_pow2, opids, opids_count, predefineds, mins, maxs);
        }
    }
}

private function createPreMetadata() {
    if (proof.std.rc.num_u8_airgroup > 0) {
        @u8air{airgroup_id: proof.std.u8.airgroup_id, air_id: proof.std.u8.air_id};
    }

    if (proof.std.rc.num_u8ext_airgroup > 0) {
        @u8airext{airgroup_id: proof.std.u8ext.airgroup_id, air_id: proof.std.u8ext.air_id};
    }

    if (proof.std.rc.num_u16_airgroup > 0) {
        @u16air{airgroup_id: proof.std.u16.airgroup_id, air_id: proof.std.u16.air_id};
    }
}

private function createMetadata() {
    @specified_ranges{airgroup_id: proof.std.specified.airgroup_id, air_id: proof.std.specified.air_id};
}
