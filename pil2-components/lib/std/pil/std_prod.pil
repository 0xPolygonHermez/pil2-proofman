require "std_constants.pil";
require "std_tools.pil";

const int PROD_TYPE_ASSUMES = 0;
const int PROD_TYPE_PROVES = 1;
const int PROD_TYPE_FREE = 2;
const int PROD_TYPE_REDUCED_ASSUMES = 3;
const int PROD_TYPE_REDUCED_PROVES = 4;

const int two_inv = 1/2;

// Control how the expressions are grouped
int PROD_EXPRESSIONS_IM_NON_REDUCED = 0; // Set to -1 to non-reduce all the terms

function prod_set_expressions_im_non_reduced(const int num) {
    if (num < -1) {
        error(`The non-reduced value must be at least -1, but received ${num}`);
    }

    PROD_EXPRESSIONS_IM_NON_REDUCED = num;
}

function prod(const int name, const int type, const int opid, const expr expressions[], const expr sel = 1, const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    assert(type == PROD_TYPE_ASSUMES || type == PROD_TYPE_PROVES || type == PROD_TYPE_FREE);
    update_piop_prod(name, type, opid, sel, expressions, direct_type);
}

function prod_assumes(const int name, const int opid, const expr expressions[], const expr sel = 1, const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    prod(name, PROD_TYPE_ASSUMES, opid, expressions, sel, direct_type);
}

function prod_proves(const int name, const int opid, const expr expressions[], const expr sel = 1, const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    prod(name, PROD_TYPE_PROVES, opid, expressions, sel, direct_type);
}

/**
 * It updates the product check constraints.
 *
 * @param name        The name of the PIOP consuming the product check
 * @param type        The type of the PIOP
 * @param opid        The ID that uniquely identifies the PIOP in the bus
 * @param sel         The selector of the PIOP
 * @param expressions The vector of expressions of the PIOP
 * @param direct_type Defines wheter the update has to be done at the global, air or default level
 */
private function update_piop_prod(const int name, const int type, const int opid, const expr sel, const expr expressions[], const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    const string name_str = get_piop_name(name);
    const int exprs_num = length(expressions);
    if (exprs_num < 1) {
        error(`The number of expressions of ${name_str} #${opid} must be at least 1`);
    }

    init_proof_containers_prod(name, opid);

    if (direct_type == PIOP_DIRECT_TYPE_AIR || direct_type == PIOP_DIRECT_TYPE_DEFAULT) {
        init_air_containers_prod(name);
    }

    // Create debug hints for the witness computation
    string name_expr[exprs_num];
    expr sum_expr = 0;
    for (int i = 0; i < exprs_num; i++) {
        name_expr[i] = string(expressions[i]);
        sum_expr += expressions[i];
    }

    // TODO: Redo when ternary operator works properly over expressions
    expr type_hint;
    if (type == PROD_TYPE_FREE) {
        type_hint = sel;
    } else {
        type_hint = type;
    }
    @gprod_debug_data{name_piop: name_str, name_expr: name_expr, busid: opid, is_global: direct_type == PIOP_DIRECT_TYPE_GLOBAL,
                           type: type_hint, selector: sel, expressions: expressions, deg_expr: degree(sum_expr), deg_sel: degree(sel)};

    initial_checks_prod(name_str, type, opid, exprs_num, direct_type);

    // selected vector to simple expression reduction
    expr exprs_compressed = compress_exprs(opid, expressions);

    switch (direct_type) {
        case PIOP_DIRECT_TYPE_GLOBAL:
            if (STD_MODE == STD_MODE_ONE_INSTANCE) {
                error("Updating the global constraint is not allowed in one instance mode");
            }

            gprod_update_global_constraint_data(type, sel, exprs_compressed);
        case PIOP_DIRECT_TYPE_AIR, PIOP_DIRECT_TYPE_DEFAULT:
            gprod_update_air_constraint_data(type, sel, exprs_compressed, direct_type);

            // Update the constraints at the air level
            on final air piop_gprod_air();

            // Update the constraints at the airgroup level
            if (STD_MODE != STD_MODE_ONE_INSTANCE) {
                on final airgroup piop_gprod_airgroup();
            }
        default:
            error(`Invalid direct_type: ${direct_type}`);
    }

    // Update the constraints at the proof level
    if (STD_MODE != STD_MODE_ONE_INSTANCE) {
        on final proof piop_gprod_proof();
    }

    // At the end, check consistency of all the opids
    on final proof check_opids_were_completed_prod();

    // Generate global hints
    on final proof piop_gprod_issue_global_hints(); 
}

private function init_proof_containers_prod(const int name, const int opid) {
    container proof.std.gprod {
        // Used for final checks
        int opids_count = 0;
        int opids[ARRAY_SIZE];

        // Resulting product of every airgroup and every air
        // It is the accumulation of each partial product that each air 
        // constributes to.
        expr gprod = 1;

        // Direct-related data, used to update `gprod` at the proof level
        int direct_gprod_nargs = 0;
        int direct_gprod_type[ARRAY_SIZE];
        expr direct_gprod_s[ARRAY_SIZE];
        expr direct_gprod_e[ARRAY_SIZE];

        // For global hints
        int air_count = 0;
        int airgroup_ids[ARRAY_SIZE];
        int air_ids[ARRAY_SIZE];
        int std_mode[ARRAY_SIZE];
    }

    // Opid-specific data
    // It must be defined at the proof level because the same opid can appear in different airs
    container proof.std.gprod.`id${opid}` {
        int name = name;
        int expressions;
        int proves = 0;
        int assumes = 0;
    }
}

private function init_air_containers_prod(const int name) {
    // AIR-specific data
    container air.std.gprod {
        // Assumes and proves of the air
        int gprod_nargs = 0;
        int gprod_type[ARRAY_SIZE];
        expr gprod_s[ARRAY_SIZE];
        expr gprod_e[ARRAY_SIZE];

        // Direct-related data, used to update `gprod` at the air level
        int direct_gprod_nargs = 0;
        int direct_gprod_type[ARRAY_SIZE];
        expr direct_gprod_s[ARRAY_SIZE];
        expr direct_gprod_e[ARRAY_SIZE];
    }
}

private function initial_checks_prod(const string name, const int type, const int opid, const int exprs_num, const int direct_type) {
    // Assumes and proves of the same opid must have the same number of expressions
    if (proof.std.gprod.`id${opid}`.expressions == 0) {
        // The first time we see this opid, we store the number of expressions
        proof.std.gprod.`id${opid}`.expressions = exprs_num;

        // Store the opid to check at the end that all the opids have been completed
        proof.std.gprod.opids[proof.std.gprod.opids_count] = opid;
        proof.std.gprod.opids_count++;
    } else if (exprs_num != proof.std.gprod.`id${opid}`.expressions) {
        // If this is not the first time we see this opid, we check that the number of expressions is the same
        const int expected_exprs = proof.std.gprod.`id${opid}`.expressions;
        error(`The number of expressions of ${name} #${opid} must be ${expected_exprs} but was ${exprs_num}`);
    }

    // The same opid can appear in different airs, so we keep track of the number of proves and assumes
    // for final checks
    if (type == PROD_TYPE_FREE) {
        // If the user is responsible for the use of proves and assumes, then mark both
        proof.std.gprod.`id${opid}`.proves++;
        proof.std.gprod.`id${opid}`.assumes++;
    } else {
        // Otherwise, we mark it correctly
        string is_proves_str;
        if (type == PROD_TYPE_PROVES) {
            is_proves_str = "proves";
        } else {
            is_proves_str = "assumes";
        }
        proof.std.gprod.`id${opid}`.`${is_proves_str}`++;
    }
}

private function gprod_update_global_constraint_data(const int type, const expr sel, const expr exprs) {
    use proof.std.gprod;

    direct_gprod_type[direct_gprod_nargs] = type;
    direct_gprod_s[direct_gprod_nargs] = sel;
    direct_gprod_e[direct_gprod_nargs] = exprs;
    direct_gprod_nargs++;
}

private function gprod_update_air_constraint_data(const int type, const expr sel, const expr exprs, const int direct_type) {
    use air.std.gprod;

    if (direct_type == PIOP_DIRECT_TYPE_AIR) {
        direct_gprod_type[direct_gprod_nargs] = type;
        direct_gprod_s[direct_gprod_nargs] = sel;
        direct_gprod_e[direct_gprod_nargs] = exprs;
        direct_gprod_nargs++;
    } else {
        gprod_type[gprod_nargs] = type;
        gprod_s[gprod_nargs] = sel;
        gprod_e[gprod_nargs] = exprs;
        gprod_nargs++;
    }
}

// Deferred functions
private function piop_gprod_air() {
    use air.std.gprod;

    const expr L1 = get_L1(); // [1,0,...]

    col witness stage(2) gprod;

    if (STD_MODE != STD_MODE_ONE_INSTANCE) {
        airgroupval aggregate(prod) default(1) gprod_result;
    }

    /*
    We need to check the constraint:
                                              ∏ᵢ (stᵢ·(tᵢ+ɣ-1)+1)       (shₖ·(shₖ+1)/2·(hₖ+ɣ-1)+1)
        gprod === ('gprod * (1 - L1) + L1) *  -------------------- * ∏ₖ --------------------------
                                              ∏ⱼ (sfⱼ·(fⱼ+ɣ-1)+1)       (shₖ·(shₖ-1)/2·(hₖ+ɣ-1)+1)
    where degree(gprod),degree(L1) = 1.

    There are three groups of expressions: t-expressions, f-expressions and h-expressions.
        - t-expressions are the ones that are proved (placed in the grand-product numerator).
        - f-expressions are the ones that are assumed (placed in the grand-product denominator).
        - h-expressions are the ones that are "free", i.e., the user is responsible for assuming or proving them.
          For this reason, we should place h-expressions both in the numerator and denominator,
          and the idea is that when the user selects `sh = 1`, it is a prove, and when `sh = -1`, it is an assume.
          Notice that (sh·(sh+1)/2·(h+ɣ-1)+1) = 1 if sh = 0,-1 and equals to h+ɣ if sh = 1.
          Similarly, (sh·(sh-1)/2·(h+ɣ-1)+1) = 1 if sh = 0,1 and equals to h+ɣ if sh = -1.

        For optimization purposes, we perform the reduction:
                 expr1·expr2·...·exprN        numerator  
                ----------------------- ==> -------------
                 expr1·expr2·...·exprM       denominator 
        with degree(numerator) <= MAX_CONSTRAINT_DEGREE-2 and degree(denominator) <= MAX_CONSTRAINT_DEGREE-1.

        We first group the expressions in two clusters: low-degree and high-degree terms;
        and then we create intermediates to perform the previous reduction.

        LOW-DEGREE TERMS:
        ==================
        There are two possible strategies to reduce low-degree terms:
            1) We define intermediates im such that
                            expr1·...·exprN  
                    im === -------------------,
                            expr1'·...·exprM'
                with N <= MAX_CONSTRAINT_DEGREE,M <= MAX_CONSTRAINT_DEGREE-1.
            2) We define intermediates im such that:
                    1        expr1'·...·exprN'  
                    ---- === ----------------------,
                    im        expr1·...·exprM 
                with M <= MAX_CONSTRAINT_DEGREE,N <= MAX_CONSTRAINT_DEGREE-1.

        HIGH-DEGREE TERMS:
        ==================
        To reduce high-degree terms, we first reduce them to low-degree terms by replacing
        each high-degree term by an intermediate. Then, we apply the low-degree strategy.
    */

    if (!defined(std_gamma)) {
        challenge stage(2) std_gamma;
    }

    // Compute the number of terms that are not reduced
    int num_non_reduced = PROD_EXPRESSIONS_IM_NON_REDUCED;
    if ((PROD_EXPRESSIONS_IM_NON_REDUCED == -1) || (gprod_nargs < PROD_EXPRESSIONS_IM_NON_REDUCED)) {
        num_non_reduced = gprod_nargs;
    }

    // The first num_non_reduced terms are not reduced
    expr numerator_non_reduced = 1;
    expr denominator_non_reduced = 1;
    for (int i = 0; i < num_non_reduced; i++) {
        const int type = gprod_type[i];
        const expr s = gprod_s[i];
        const expr e = gprod_e[i];
        if (type == PROD_TYPE_ASSUMES) {
            // The expression is of the form 1/(s·(e+ɣ-1)+1)
            denominator_non_reduced *= (s * (e + std_gamma - 1) + 1);
        } else if (type == PROD_TYPE_PROVES) {
            // The expression is of the form (s·(e+ɣ-1)+1)
            numerator_non_reduced *= (s * (e + std_gamma - 1) + 1);
        } else {
            // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)/(s·(s-1)/2·(e+ɣ-1)+1)
            numerator_non_reduced *= (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);
            denominator_non_reduced *= (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);
        }
    }

    expr numerator = 1;
    expr denominator = 1;
    const int num_terms = gprod_nargs - num_non_reduced;
    if (num_terms > 0) {
        // Identify the isolated term
        int isolated_numerator_term = -1;
        int isolated_denominator_term = -1;
        for (int i = num_non_reduced; i < gprod_nargs; i++) {
            const int type = gprod_type[i];
            const int s_degree = degree(gprod_s[i]);
            const int e_degree = degree(gprod_e[i]);
            if (type == PROD_TYPE_ASSUMES) {
                // The expression is of the form 1/(s·(e+ɣ-1)+1)
                const int degree = s_degree + e_degree;
                if ((degree > 0) && (degree <= MAX_CONSTRAINT_DEGREE-1) && (isolated_denominator_term == -1)) {
                    isolated_denominator_term = i;
                }
            } else if (type == PROD_TYPE_PROVES) {
                // The expression is of the form (s·(e+ɣ-1)+1)
                const int degree = s_degree + e_degree;
                if ((degree > 0) && (degree <= MAX_CONSTRAINT_DEGREE-2) && (isolated_numerator_term == -1)) {
                    isolated_numerator_term = i;
                }
            } else {
                // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)/(s·(s-1)/2·(e+ɣ-1)+1)
                const int degree = 2 * s_degree + e_degree;
                if ((degree == MAX_CONSTRAINT_DEGREE-1) && (isolated_denominator_term == -1)) {
                    isolated_denominator_term = i;
                } else if ((degree > 0) && (degree <= MAX_CONSTRAINT_DEGREE-2)) {
                    if (isolated_numerator_term == -1) {
                        isolated_numerator_term = i;
                    }
                    if (isolated_denominator_term == -1) {
                        isolated_denominator_term = i;
                    }
                }
            }

            // If both isolated terms have been assigned, break
            if ((isolated_numerator_term != -1) && (isolated_denominator_term != -1)) {
                break;
            }
        }

        // Group the terms depending on their degree
        // TODO: To optimize this even further, I would need to order the terms by their degree
        int high_degree_term[num_terms];
        int high_degree_len = 0;
        int low_degree_term_numerator[num_terms];
        int low_degree_term_denominator[num_terms];
        int low_degree_term_numerator_degree[num_terms];
        int low_degree_term_denominator_degree[num_terms];
        int low_degree_len_numerator = 0;
        int low_degree_len_denominator = 0;
        for (int i = num_non_reduced; i < gprod_nargs; i++) {
            // If the isolated terms have already been identified, continue
            if ((i == isolated_numerator_term) || (i == isolated_denominator_term)) {
                continue;
            }

            const int type = gprod_type[i];
            const expr s = gprod_s[i];
            const expr e = gprod_e[i];
            const int s_degree = degree(s);
            const int e_degree = degree(e);

            int degree;
            if ((type == PROD_TYPE_ASSUMES) || (type == PROD_TYPE_PROVES)) {
                // The expression is of the form (s·(e+ɣ-1)+1)
                degree = s_degree + e_degree;
            } else {
                // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)/(s·(s-1)/2·(e+ɣ-1)+1)
                degree = 2*s_degree + e_degree;
            }

            // If the expression is a constant, we can directly add it to the direct terms
            if (degree == 0) 
            {
                direct_gprod_type[direct_gprod_nargs] = type;
                direct_gprod_s[direct_gprod_nargs] = s;
                direct_gprod_e[direct_gprod_nargs] = e;
                direct_gprod_nargs++;
            }
            // Low-degree terms are those with degree <= MAX_CONSTRAINT_DEGREE
            else if (degree <= MAX_CONSTRAINT_DEGREE) 
            {
                if (type == PROD_TYPE_ASSUMES) {
                    low_degree_term_denominator[low_degree_len_denominator] = i;
                    low_degree_term_denominator_degree[low_degree_len_denominator] = degree;
                    low_degree_len_denominator++;
                } else if (type == PROD_TYPE_PROVES) {
                    low_degree_term_numerator[low_degree_len_numerator] = i;
                    low_degree_term_numerator_degree[low_degree_len_numerator] = degree;
                    low_degree_len_numerator++;
                } else {
                    low_degree_term_numerator[low_degree_len_numerator] = i;
                    low_degree_term_numerator_degree[low_degree_len_numerator] = degree;
                    low_degree_len_numerator++;
                    low_degree_term_denominator[low_degree_len_denominator] = i;
                    low_degree_term_denominator_degree[low_degree_len_denominator] = degree;
                    low_degree_len_denominator++;
                }
            }
            // High-degree terms are those with degree > MAX_CONSTRAINT_DEGREE
            else 
            {
                high_degree_term[high_degree_len] = i;
                high_degree_len++;
                if (type == PROD_TYPE_FREE) {
                    high_degree_len++;
                }
            }
        }

        // Start with the high-degree terms
        if (high_degree_len > 0) {
            // Reduce the high-degree terms to low-degree terms. 
            // In fact, we reduce them to terms of degree 1. TODO: We can optimize this further
            col witness stage(2) im_high[high_degree_len];
            int offset = 0;
            for (int i = 0; i < high_degree_len; i++) {
                int idx = offset + i;
                const int term = high_degree_term[idx];
                const int type = gprod_type[term];
                const expr s = gprod_s[term];
                const expr e = gprod_e[term];
                if ((type == PROD_TYPE_ASSUMES) || (type == PROD_TYPE_PROVES)) {
                    // The expression is of the form (s·(e+ɣ-1)+1)
                    const expr rhs = (s * (e + std_gamma - 1) + 1);

                    // Check the correctness of the intermediate
                    @im_col{reference: im_high[idx], numerator: rhs, denominator: 1};
                    im_high[idx] === rhs;

                    // Update the low-degree terms
                    gprod_e[term] = im_high[idx];
                    if (type == PROD_TYPE_ASSUMES) {
                        gprod_type[term] = PROD_TYPE_REDUCED_ASSUMES;
                        low_degree_term_denominator[low_degree_len_denominator] = term;
                        low_degree_term_denominator_degree[low_degree_len_denominator] = 1;
                        low_degree_len_denominator++;
                    } else {
                        gprod_type[term] = PROD_TYPE_REDUCED_PROVES;
                        low_degree_term_numerator[low_degree_len_numerator] = term;
                        low_degree_term_numerator_degree[low_degree_len_numerator] = 1;
                        low_degree_len_numerator++;
                    }
                } else {
                    // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)/(s·(s-1)/2·(e+ɣ-1)+1)
                    const expr rhs1 = (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);

                    // Check the correctness of the intermediates
                    @im_col{reference: im_high[idx], numerator: rhs1, denominator: 1};
                    im_high[idx] === rhs1;

                    // Update the low-degree terms
                    gprod_type[term] = PROD_TYPE_REDUCED_PROVES;
                    gprod_e[term] = im_high[idx];
                    low_degree_term_numerator[low_degree_len_numerator] = term;
                    low_degree_term_numerator_degree[low_degree_len_numerator] = 1;
                    low_degree_len_numerator++;

                    idx++;
                    const expr rhs2 = (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);

                    // Check the correctness of the intermediate
                    @im_col{reference: im_high[idx], numerator: rhs2, denominator: 1};
                    im_high[idx] === rhs2;

                    // Update the low-degree terms
                    gprod_type[term] = PROD_TYPE_REDUCED_ASSUMES;
                    gprod_e[term] = im_high[idx];
                    low_degree_term_denominator[low_degree_len_denominator] = term;
                    low_degree_term_denominator_degree[low_degree_len_denominator] = 1;
                    low_degree_len_denominator++;

                    offset++;
                }
            }
        }

        // Now treat the low-degree terms
        if (low_degree_len_numerator + low_degree_len_denominator > 0) {
            // Count the number of groups that I need to form based on their degree
            int k = 0;
            int k_type[low_degree_len_numerator + low_degree_len_denominator];
            int offset_num = 0;
            int offset_den = 0;
            int acc_degree_num = 0;
            int acc_degree_den = 0;
            while ((offset_num < low_degree_len_numerator) || (offset_den < low_degree_len_denominator)) {
                for (int j = offset_num; j < low_degree_len_numerator; j++) {
                    acc_degree_num += low_degree_term_numerator_degree[j];
                    offset_num++;
                    int next_degree_num = 0;
                    if (j < low_degree_len_numerator - 1) {
                        next_degree_num = low_degree_term_numerator_degree[j + 1];
                    }
                    if (acc_degree_num + next_degree_num > MAX_CONSTRAINT_DEGREE) {
                        break;
                    }
                }
                for (int j = offset_den; j < low_degree_len_denominator; j++) {
                    acc_degree_den += low_degree_term_denominator_degree[j];
                    offset_den++;
                    int next_degree_den = 0;
                    if (j < low_degree_len_denominator - 1) {
                        next_degree_den = low_degree_term_denominator_degree[j + 1];
                    }
                    if (acc_degree_den + next_degree_den > MAX_CONSTRAINT_DEGREE) {
                        break;
                    }
                }

                if ((acc_degree_num == MAX_CONSTRAINT_DEGREE) && (acc_degree_den == MAX_CONSTRAINT_DEGREE)) {
                    // We have a perfect match, we need to descrease the offset of some by one and form a group
                    if (low_degree_term_numerator_degree[offset_num - 1] >= low_degree_term_denominator_degree[offset_den - 1]) {
                        offset_den--;
                        k_type[k] = 0; // Create im that ends in the numerator
                        acc_degree_num = 1;
                        acc_degree_den = 0;
                    } else {
                        offset_num--;
                        k_type[k] = 1; // Create im that ends in the denominator
                        acc_degree_num = 0;
                        acc_degree_den = 1;
                    }
                } else if (acc_degree_num == MAX_CONSTRAINT_DEGREE) {
                    k_type[k] = 0; // Create im that ends in the numerator
                    acc_degree_num = 1;
                    acc_degree_den = 0;
                } else if (acc_degree_den == MAX_CONSTRAINT_DEGREE) {
                    k_type[k] = 1; // Create im that ends in the denominator
                    acc_degree_num = 0;
                    acc_degree_den = 1;
                } else {
                    // In any other case, choose any type and form the group
                    k_type[k] = 0;
                    acc_degree_num = 1;
                    acc_degree_den = 0;
                }
                k++;
            }

            // Apply the strategy
            col witness stage(2) im_low[k];
            expr prev_im = 1;
            offset_num = 0;
            offset_den = 0;
            for (int i = 0; i < k; i++) {
                if (k_type[i] == 0) { // If the im ends in the numerator
                    // We define an intermediate im such that
                    //           expr1·...·exprN  
                    //  im === ------------------- <==> im·expr1'·...·exprM' === expr1·...·exprN, with N <= MAX_CONSTRAINT_DEGREE,M <= MAX_CONSTRAINT_DEGREE-1
                    //          expr1'·...·exprM'
                    
                    // 1] Compute the RHS
                    expr rhs = 1;
                    if ((i > 0) && (k_type[i - 1] == 0)) {
                        // If the previous im ends in the numerator, we need to start at the previous im
                        rhs = prev_im;
                    }
                    int degree = degree(rhs);
                    int next_degree = 0;
                    if (offset_num < low_degree_len_numerator - 1) {
                        next_degree = low_degree_term_numerator_degree[offset_num];
                    }
                    while ((offset_num < low_degree_len_numerator) && (degree + next_degree <= MAX_CONSTRAINT_DEGREE)) {
                        const int term = low_degree_term_numerator[offset_num];
                        const int type = gprod_type[term];
                        const expr s = gprod_s[term];
                        const expr e = gprod_e[term];
                        if (type == PROD_TYPE_REDUCED_PROVES) {
                            // The expression is of the form e
                            rhs *= e;
                        } else if (type == PROD_TYPE_PROVES) {
                            // The expression is of the form (s·(e+ɣ-1)+1)
                            rhs *= (s * (e + std_gamma - 1) + 1);
                        } else if (type == PROD_TYPE_FREE) {
                            // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)
                            rhs *= (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);
                        }
                        degree += low_degree_term_numerator_degree[offset_num];
                        offset_num++;
                    }

                    // 2] Compute the LHS
                    expr lhs = 1;
                    if ((i > 0) && (k_type[i - 1] == 1)) {
                        // If the previous im ends in the denominator, we need to start at the previous im
                        lhs = prev_im;
                    }
                    degree = degree(lhs);
                    next_degree = 0;
                    if (offset_den < low_degree_len_denominator - 1) {
                        next_degree = low_degree_term_denominator_degree[offset_den];
                    }
                    while ((offset_den < low_degree_len_denominator) && (degree + next_degree < MAX_CONSTRAINT_DEGREE)) {
                        const int term = low_degree_term_denominator[offset_den];
                        const int type = gprod_type[term];
                        const expr s = gprod_s[term];
                        const expr e = gprod_e[term];
                        if (type == PROD_TYPE_REDUCED_ASSUMES) {
                            // The expression is of the form e
                            lhs *= e;
                        } else if (type == PROD_TYPE_ASSUMES) {
                            // The expression is of the form (s·(e+ɣ-1)+1)
                            lhs *= (s * (e + std_gamma - 1) + 1);
                        } else if (type == PROD_TYPE_FREE) {
                            // The expression is of the form (s·(s-1)/2·(e+ɣ-1)+1)
                            lhs *= (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);
                        }
                        degree += low_degree_term_denominator_degree[offset_den];
                        offset_den++;
                    }

                    // Check the correctness of the intermediate
                    @im_col{reference: im_low[i], numerator: rhs, denominator: lhs};
                    im_low[i] * lhs === rhs;

                    // Set the previous im
                    prev_im = im_low[i];

                    // Set the numerator and denominator as:
                    //  prev_im·expr    
                    // -------------- with degree(expr) <= MAX_CONSTRAINT_DEGREE-3 and degree(expr') <= MAX_CONSTRAINT_DEGREE-1
                    //     expr'  
                    numerator = prev_im;
                } else {
                    // We define an intermediate im such that
                    //  1        expr1'·...·exprN'  
                    // ---- === ---------------------- <==> expr1·...·exprM === im·expr1'·...·exprN', with M <= MAX_CONSTRAINT_DEGREE,N <= MAX_CONSTRAINT_DEGREE-1
                    //  im        expr1·...·exprM 

                    // 1] Compute the LHS
                    expr lhs = 1;
                    if ((i > 0) && (k_type[i - 1] == 1)) {
                        // If the previous im ends in the denominator, we need to start at the previous im
                        lhs = prev_im;
                    }
                    int degree = degree(lhs);
                    int next_degree = 0;
                    if (offset_den < low_degree_len_denominator - 1) {
                        next_degree = low_degree_term_denominator_degree[offset_den];
                    }
                    while ((offset_den < low_degree_len_denominator) && (degree + next_degree <= MAX_CONSTRAINT_DEGREE)) {
                        const int term = low_degree_term_denominator[offset_den];
                        const int type = gprod_type[term];
                        const expr s = gprod_s[term];
                        const expr e = gprod_e[term];
                        if (type == PROD_TYPE_REDUCED_ASSUMES) {
                            // The expression is of the form e
                            lhs *= e;
                        } else if (type == PROD_TYPE_ASSUMES) {
                            // The expression is of the form (s·(e+ɣ-1)+1)
                            lhs *= (s * (e + std_gamma - 1) + 1);
                        } else if (type == PROD_TYPE_FREE) {
                            // The expression is of the form (s·(s-1)/2·(e+ɣ-1)+1)
                            lhs *= (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);
                        }
                        degree += low_degree_term_denominator_degree[offset_den];
                        offset_den++;
                    }

                    // 2] Compute the RHS
                    expr rhs = 1;
                    if ((i > 0) && (k_type[i - 1] == 0)) {
                        // If the previous im ends in the numerator, we need to start at the previous im
                        rhs = prev_im;
                    }
                    degree = degree(rhs);
                    next_degree = 0;
                    if (offset_num < low_degree_len_numerator - 1) {
                        next_degree = low_degree_term_numerator_degree[offset_num];
                    }
                    while ((offset_num < low_degree_len_numerator) && (degree + next_degree < MAX_CONSTRAINT_DEGREE)) {
                        const int term = low_degree_term_numerator[offset_num];
                        const int type = gprod_type[term];
                        const expr s = gprod_s[term];
                        const expr e = gprod_e[term];
                        if (type == PROD_TYPE_REDUCED_PROVES) {
                            // The expression is of the form e
                            rhs *= e;
                        } else if (type == PROD_TYPE_PROVES) {
                            // The expression is of the form (s·(e+ɣ-1)+1)
                            rhs *= (s * (e + std_gamma - 1) + 1);
                        } else if (type == PROD_TYPE_FREE) {
                            // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)
                            rhs *= (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);
                        }
                        degree += low_degree_term_numerator_degree[offset_num];
                        offset_num++;
                    }

                    // Check the correctness of the intermediate
                    @im_col{reference: im_low[i], numerator: lhs, denominator: rhs};
                    lhs === im_low[i] * rhs;

                    // Set the previous expr as the intermediate
                    prev_im = im_low[i];

                    // Set the numerator and denominator as:
                    //      expr'     
                    // -------------- with degree(expr'),degree(expr) <= MAX_CONSTRAINT_DEGREE-2
                    //  prev_im·expr   
                    denominator = prev_im;
                }
            }
        }

        /*
            At this point, the constraint has been transformed to:
                                                      numerator_non_reduced       iso_num      numerator  
                gprod === ('gprod * (1 - L1) + L1) * ------------------------- * --------- * -------------
                                                      denominator_non_reduced     iso_den     denominator 

            The missing part is to reduce the isolated terms with the numerator and denominator.
        */
        // Reduce the numerator
        if (isolated_numerator_term != -1) {
            const int type = gprod_type[isolated_numerator_term];
            const expr s = gprod_s[isolated_numerator_term];
            const expr e = gprod_e[isolated_numerator_term];
           if (type == PROD_TYPE_PROVES) {
                // The expression is of the form (s·(e+ɣ-1)+1)
                numerator *= (s * (e + std_gamma - 1) + 1);
            } else if (type == PROD_TYPE_FREE) {
                // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)
                numerator *= (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);
            }

            if (degree(numerator) > MAX_CONSTRAINT_DEGREE-2) {
                col witness stage(2) im_num_extra;

                // Check the correctness of the intermediate
                @im_col{reference: im_num_extra, numerator: numerator, denominator: 1};
                im_num_extra === numerator;

                numerator = im_num_extra;
            }
        }

        if (isolated_denominator_term != -1) {
            const int type = gprod_type[isolated_denominator_term];
            const expr s = gprod_s[isolated_denominator_term];
            const expr e = gprod_e[isolated_denominator_term];
            if (type == PROD_TYPE_ASSUMES) {
                // The expression is of the form 1/(s·(e+ɣ-1)+1)
                denominator *= (s * (e + std_gamma - 1) + 1);
            } else if (type == PROD_TYPE_FREE) {
                // The expression is of the form 1/(s·(s-1)/2·(e+ɣ-1)+1)
                denominator *= (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);
            }

            if (degree(denominator) > MAX_CONSTRAINT_DEGREE-1) {
                col witness stage(2) im_den_extra;

                // Check the correctness of the intermediate
                @im_col{reference: im_den_extra, numerator: denominator, denominator: 1};
                im_den_extra === denominator;

                denominator = im_den_extra;
            }
        }
    }

    /*
        At this point, the constraint has been transformed to:
                                                   numerator_non_reduced       numerator  
            gprod === ('gprod * (1 - L1) + L1) * ------------------------- * -------------
                                                  denominator_non_reduced     denominator 
        check that the constraint is satisfied
    */
    gprod * denominator_non_reduced * denominator === ('gprod * (1 - L1) + L1) * numerator_non_reduced * numerator;

    /*
        At the very last row, it should be satisfied that:
                                    ∏ᵢ (stᵢ·(tᵢ+ɣ-1)+1)       (shₖ·(shₖ+1)/2·(hₖ+ɣ-1)+1)
            gprod_result === gprod *  -------------------- * ∏ₖ --------------------------
                                    ∏ⱼ (sfⱼ·(fⱼ+ɣ-1)+1)       (shₖ·(shₖ-1)/2·(hₖ+ɣ-1)+1)
        where all stᵢ,tᵢ,sfⱼ,fⱼ,shₖ,hₖ are field elements, for all i, j, k
    */

    expr direct_gprod_num = 1;
    expr direct_gprod_den = 1;
    for (int i = 0; i < direct_gprod_nargs; i++) {
        const int type = direct_gprod_type[i];
        const expr s = direct_gprod_s[i];
        const expr e = direct_gprod_e[i];
        switch (type) {
            case PROD_TYPE_ASSUMES:
                // The expression is of the form (s·(e+ɣ-1)+1)
                direct_gprod_den *= (s * (e + std_gamma - 1) + 1);
            case PROD_TYPE_PROVES:
                // The expression is of the form (s·(e+ɣ-1)+1)
                direct_gprod_num *= (s * (e + std_gamma - 1) + 1);
            case PROD_TYPE_FREE:
                // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)/(s·(s-1)/2·(e+ɣ-1)+1)
                direct_gprod_num *= (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);
                direct_gprod_den *= (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);
            default:
                error(`Invalid gprod_type: ${type}`);
        }
    }

    expr result;
    if (STD_MODE == STD_MODE_ONE_INSTANCE) {
        result = 1;
    } else {
        result = gprod_result;
    }
    @gprod_col{reference: gprod, numerator_air: numerator, denominator_air: denominator, 
               numerator_direct: direct_gprod_num, denominator_direct: direct_gprod_den,
               result: result};
    L1' * (result * direct_gprod_den - gprod * direct_gprod_num) === 0;

    // Store the airgroup and air ids for global hints
    proof.std.gprod.airgroup_ids[proof.std.gprod.air_count] = AIRGROUP_ID;
    proof.std.gprod.air_ids[proof.std.gprod.air_count] = AIR_ID;
    proof.std.gprod.std_mode[proof.std.gprod.air_count] = STD_MODE;
    proof.std.gprod.air_count++;
}

// Note: We don't "update" the prod at the airgroup level (i.e., all the resulting prods generated by each air)
//       because we don't know how many airs will be generated at compile time. Therefore we use the same
//       term to refer to both things: the value generated at each air and the value generated at each airgroup.
//       It is like jumping from the air level to the proof (global) level, from the constraint point of view.

private function piop_gprod_airgroup() {
    // The `gprod_result` from each airgroup is added to the overall global product
    proof.std.gprod.gprod *= gprod_result;
}

private function piop_gprod_proof() {
    use proof.std.gprod;

    /*
    The accumulated product at the proof level must satisfy that:

                 ∏ᵢ (stᵢ·(tᵢ+ɣ-1)+1)       (shₖ·(shₖ+1)/2·(hₖ+ɣ-1)+1)
        gprod *  -------------------- * ∏ₖ -------------------------- === 1
                 ∏ⱼ (sfⱼ·(fⱼ+ɣ-1)+1)       (shₖ·(shₖ-1)/2·(hₖ+ɣ-1)+1)

    Note: We cannot update this constraint directly if some of the elements
        are not globally defined: constants, public inputs, airgroupvalues, ...
    */

    expr numerator = 1;
    expr denominator = 1;
    for (int i = 0; i < direct_gprod_nargs; i++) {
        const int type = direct_gprod_type[i];
        const expr s = direct_gprod_s[i];
        const expr e = direct_gprod_e[i];
        switch (type) {
            case PROD_TYPE_ASSUMES:
                // The expression is of the form (s·(e+ɣ-1)+1)
                denominator *= (s * (e + std_gamma - 1) + 1);
            case PROD_TYPE_PROVES:
                // The expression is of the form (s·(e+ɣ-1)+1)
                numerator *= (s * (e + std_gamma - 1) + 1);
            case PROD_TYPE_FREE:
                // The expression is of the form (s·(s+1)/2·(e+ɣ-1)+1)/(s·(s-1)/2·(e+ɣ-1)+1)
                numerator *= (s * (s + 1) * two_inv * (e + std_gamma - 1) + 1);
                denominator *= (s * (s - 1) * two_inv * (e + std_gamma - 1) + 1);
            default:
                error(`Invalid gprod_type: ${type}`);
        }
    }

    gprod * numerator === denominator;
}

private function check_opids_were_completed_prod() {
    for (int i = 0; i < proof.std.gprod.opids_count; i++) {
        int opid = proof.std.gprod.opids[i];
        use proof.std.gprod.`id${opid}`;

        // If the PIOP is isolated, avoid any check
        if (name == PIOP_NAME_ISOLATED) continue;

        const string name_str = get_piop_name(name);

        // At least one assume and one prove must be defined
        if (assumes == 0) {
            error(`${name_str} #${opid} defined without assume`);
        } else if (proves == 0) {
            error(`${name_str} #${opid} defined without proves`);
        }
    }
}

private function piop_gprod_issue_global_hints() {
    use proof.std.gprod;
    @std_prod_users{num_users: air_count, std_mode: std_mode, airgroup_ids: airgroup_ids, air_ids: air_ids, stage_wc: 2};
}