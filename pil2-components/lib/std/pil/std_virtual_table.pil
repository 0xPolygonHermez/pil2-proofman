require "std_constants.pil";
require "std_lookup.pil";

int MAX_VIRTUAL_BITS = -1; // -1 indicates that the bits is specified on demand
                           // and is set to be the maximum of all specified ranges

function set_max_virtual_bits(const int bits) {
    if (bits <= 0) {
        error(`The input bits should be greater than 0, got ${bits} instead`);
    }

    MAX_VIRTUAL_BITS = bits;
}

function collect_virtual_table(const int opid, const expr table[]) {
    // Check whether the inputs are valid
    const int w = length(table);
    if (w == 0) {
        error(`Table (AIRGROUP, AIR, num_rows) = (${AIRGROUP_ID}, ${AIR_ID}, ${num_rows}) is empty`);
    }

    // We assume that all columns in a table have the same number of rows
    // and that the number of rows is a power of two.
    // TODO: Both conditions can be relaxed in the future.
    const int num_rows = Tables.num_rows(table[0]);
    if (num_rows == 0) {
        error(`Table (AIRGROUP, AIR, num_rows) = (${AIRGROUP_ID}, ${AIR_ID}, ${num_rows}) is empty`);
    } else if ((num_rows & (num_rows - 1)) != 0) {
        error(`Table (AIRGROUP, AIR, num_rows) = (${AIRGROUP_ID}, ${AIR_ID}, ${num_rows}) has a non-power-of-two number of rows: ${num_rows}`);
    }
    for (int i = 1; i < w; i++) {
        if (Tables.num_rows(table[i]) != num_rows) {
            error(`Table (AIRGROUP, AIR, num_rows) = (${AIRGROUP_ID}, ${AIR_ID}, ${num_rows}) has inconsistent number of rows`);
        }
    }

    // The first time, initialize the tables container
    container airgroup.std.virtual_table alias vt {
        expr columns[ARRAY_SIZE][32];
        int widths[ARRAY_SIZE];
        int heights[ARRAY_SIZE];
        int opids[ARRAY_SIZE];
        int amount = 0;
        int max_height = 0;
    }

    // Update the tables container
    for (int i = 0; i < w; i++) {
        vt.columns[vt.amount][i] = table[i];
    }
    vt.widths[vt.amount] = w;
    vt.heights[vt.amount] = num_rows;
    if (num_rows > vt.max_height) {
        vt.max_height = num_rows;
    }
    vt.opids[vt.amount] = opid;
    vt.amount++;

    // At the end, pack the tables
    on final(1) airgroup pack_tables();
}

/*
    Given a set of tables Tᵢ := (idᵢ, wᵢ, hᵢ), where  idᵢ is the table id, wᵢ is the width,
    and hᵢ is the height, this function packs the tables into a single table.

    The high-level idea is to first order the tables by width and then try to pack them
    assuming that:
      1. The height of the packing is a power of two.
      2. The only allowed operation is cutting the tables to stack them in some way.

    For example, if we have three tables T₁ = (0, 3, 2^10), T₂ = (1, 8, 2^4) and T₃ = (2, 4, 2^8), one option is to
    set the height to 2^9 and stack them as follows:
        =============================================================================================
         ID
        -------------------------                                            | #Fixed | #Witness(1) |
        | 0 | T₁[0] T₁[1] T₁[2] |                                            |   4    |      1      |
        ------------------------- ---> Bus                                   |        |             |
        -------------------------                                            |        |             |
        | 0 | T₁[0] T₁[1] T₁[2] |                                            |   4    |      1      |
        ------------------------- ---> Bus                                   |        |             |
        -------------------------------------------------------              |        |             |
        | 3 | T₃[0] T₃[1] T₃[2] T₃[3]   0     0     0     0   |              |   9    |      1      |
        | 2 | T₂[0] T₂[1] T₂[2] T₂[3] T₂[4] T₂[5] T₂[6] T₂[7] |              |        |             |
        | X |   0     0     0     0     0     0     0     0   |              |        |             |
        ------------------------------------------------------- ---> Bus     |        |             |
                                                                      Total: |   17   |      3      |
        =============================================================================================
    (NOTE: This is represented in vertical for space limitations, but the actual packing is horizontal)

    The size of the packing is chosen by trying to minimize the area of the resulting packing.
    Given the height of the resulting table T is H, the area of the packing is:
                        fixed_area   = H·∑ⱼ (1 + wⱼ) // ID + width
                        witness_area = H·((∑ⱼ 1) + 3 + 3*((∑ⱼ 1)//2)) // multiplicity + grand_sum + lookups_1
                        area         = fixed_area + witness_area
    where wⱼ is the width of the j-th group in the packing and ∑ⱼ 1 is the number of groups in the packing.
*/
function pack_tables() {
    println("PACKING VIRTUAL TABLES");

    use airgroup.std.virtual_table alias vt;

    // Order the tables by width in ascending order
    int ordered_tables[vt.amount];
    int total_height = 0;
    for (int i = 0; i < vt.amount; i++) {
        println(`Table OPID ${vt.opids[i]}: width = ${vt.widths[i]}, height = 2^${log2(vt.heights[i])}`);
        ordered_tables[i] = i;
        total_height += vt.heights[i];
    }

    for (int i = 0; i < vt.amount - 1; i++) {
        const int width_i = vt.widths[ordered_tables[i]];
        for (int j = i + 1; j < vt.amount; j++) {
            const int width_j = vt.widths[ordered_tables[j]];
            if (width_i > width_j) {
                int tmp_ordered = ordered_tables[i];
                ordered_tables[i] = ordered_tables[j];
                ordered_tables[j] = tmp_ordered;
            }
        }
    }

    int max_bits = 0;
    if (MAX_VIRTUAL_BITS == -1) {
        // Take the bits that makes the total height fit
        int num_rows = 1;
        while (num_rows < total_height) {
            num_rows *= 2;
            max_bits++;
        }
    } else {
        // Use the specified bits
        max_bits = MAX_VIRTUAL_BITS;
    }

    // Proceed with the packing
    int min_area;
    int bits_best_pack;
    int widths_best_pack[10*ARRAY_SIZE]; // TODO: Check
    int tables_best_pack[10*ARRAY_SIZE][vt.amount]; // TODO: Check
    int opids_best_pack[10*ARRAY_SIZE][vt.amount]; // TODO: Check
    int best_pack_lens[10*ARRAY_SIZE];
    int len_best_pack = 0;
    for (int i = max_bits; i <= max_bits; i++) { // TODO: Try all heights from 2^min_bits to 2^max_bits and choose the best one
        const int num_rows = 1 << i;
        const int num_tables = (total_height + num_rows - 1) / num_rows;
        int widths_pack[num_tables];
        int tables_pack[num_tables][vt.amount];
        int opids_pack[num_tables][vt.amount];
        int pack_lens[num_tables];
        int pack_len = 0;
        int used_area[num_tables];
        int available_height = num_rows;
        for (int j = 0; j < vt.amount; j++) {
            const int table_id = ordered_tables[j];
            const int width = vt.widths[table_id];
            int height = vt.heights[table_id];

            while (height > 0) {
                if (height <= available_height) {
                    // It fits entirely
                    available_height -= height;
                    used_area[pack_len] += width * height;
                    height = 0;
                } else {
                    // Only part fits, so cut and place what we can
                    height -= available_height;
                    used_area[pack_len] += width * available_height;
                    available_height = 0;
                }

                // Update the opids and the number of tables in the current group
                tables_pack[pack_len][pack_lens[pack_len]] = table_id;
                opids_pack[pack_len][pack_lens[pack_len]] = vt.opids[table_id];
                pack_lens[pack_len]++;

                if (available_height == 0) {
                    // Close the current table
                    widths_pack[pack_len] = width; // Since they are ordered by width,
                                                   // the width representative is the last one that fits
                    pack_len++;

                    // Start a new table
                    available_height = num_rows;
                }
            }
        }

        // If the last table is partially filled, we need to add a complete new table
        if (available_height < num_rows) {
            widths_pack[pack_len] = vt.widths[ordered_tables[vt.amount - 1]];
            pack_len++;
        }

        // Compute the area of the packing
        // fixed_area   = H·∑ⱼ (1 + wⱼ) // ID + width
        // witness_area = H·((∑ⱼ 1) + 3 + 3*((∑ⱼ 1)//2)) // multiplicity + grand_sum + lookups_1
        // area         = fixed_area + witness_area
        int wasted_area = 0;
        int fixed_area = 0;
        for (int j = 0; j < pack_len; j++) {
            wasted_area += num_rows*widths_pack[j] - used_area[j];
            fixed_area += (1 + widths_pack[j]);
        }
        const int witness_area = (pack_len + 3 + 3 * (pack_len / 2));
        const int area = num_rows * (fixed_area + witness_area);
        println(`Fixed height: 2^${i}, Wasted area: ${wasted_area}, Fixed area: ${num_rows*fixed_area}, Witness area: ${num_rows*witness_area}, Area: ${area}, #Multiplicites: ${pack_len}`);

        if ((i == max_bits) || (area < min_area)) {
            // If this is the first iteration or the area is smaller than the minimum found,
            // update the minimum area and the chosen height
            min_area = area;
            bits_best_pack = i;
            len_best_pack = pack_len;
            for (int j = 0; j < pack_len; j++) {
                widths_best_pack[j] = widths_pack[j];
                tables_best_pack[j] = tables_pack[j];
                opids_best_pack[j] = opids_pack[j];
                best_pack_lens[j] = pack_lens[j];
            }
        }
    }

    println(`Minimum area was found with height=2^${bits_best_pack}`);

    // Compute the length of the virtual table
    const int num_rows = 1 << bits_best_pack;
    VirtualTable(num_rows, opids_best_pack, tables_best_pack, widths_best_pack, best_pack_lens, len_best_pack);
}

airtemplate VirtualTable(const int N, const int opids[][], const int table_ids[][], const int widths[], const int lens[], const int num_tables) {    
    // Compute the number of fixed and witness columns
    int sum_widths = 0;
    for (int i = 0; i < num_tables; i++) {
        sum_widths += widths[i];
    }

    col fixed OPID[num_tables];
    col fixed column[sum_widths];
    col witness multiplicity[num_tables];

    // Fill the fixed columns
    int col_offset = 0;
    for (int i = 0; i < num_tables; i++) {
        // Get the opids to be filled
        const int group_len = lens[i];
        const int group_width = widths[i];
        int row_offset = 0;
        for (int j = 0; j < group_len; j++) {
            const int table_id = table_ids[i][j];
            const int height = vt.heights[table_id];
            const int width = vt.widths[table_id];
            const int opid = opids[i][j];

            int h;
            if (height < N) {
                h = height;
            } else {
                h = N;
            }
            for (int k = 0; k < h; k++) {
                OPID[i][row_offset + k] = opid;
            }

            for (int k = 0; k < width; k++) {
                Tables.copy(vt.columns[table_id][k], 0, column[col_offset + k], 0, h);
            }
            row_offset += h;
        }
        col_offset += group_width;

        int opids_to_prove[group_len];
        for (int j = 0; j < group_len; j++) {
            opids_to_prove[j] = opids[i][j];
        }

        expr cols_to_prove[group_width];
        for (int j = 0; j < group_width; j++) {
            cols_to_prove[j] = column[j];
        }

        // println(`Proving group ${i} with opids:`, opids_to_prove);

        // Perform the proving
        lookup_proves_dynamic(opids: opids_to_prove, busid: OPID[i], expressions: cols_to_prove, mul: multiplicity[i]);
    }
}