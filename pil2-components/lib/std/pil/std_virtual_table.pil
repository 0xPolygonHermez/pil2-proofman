require "std_constants.pil";
require "std_lookup.pil";

// TODO: Add the possibility of different table sizes for the different virtual tables

int MAX_VIRTUAL_ROWS = -1; // -1 indicates that the rows is specified on demand

int MAX_NUM_VIRTUAL_TABLES = 1; // Maximum number of virtual tables

const int MAX_VIRTUAL_TABLE_WIDTH = 64;
const int MAX_VIRTUAL_TABLE_IDS = 16;
const int MAX_VIRTUAL_TABLE_GROUPS = 16;

function set_max_num_rows_virtual(const int rows) {
    if (rows <= 0) {
        error(`The input rows should be greater than 0, got ${rows} instead`);
    } else if ((rows & (rows - 1)) != 0) {
        error(`The input rows should be a power of two, got ${rows} instead`);
    }

    MAX_VIRTUAL_ROWS = rows;
}

function set_max_num_virtual_tables(const int num) {
    if (num <= 0) {
        error(`The input number of virtual tables should be greater than 0, got ${num} instead`);
    } else if (num == 1) {
        println("[Warning] The number of virtual tables is 1 by default. set_num_virtual_tables(1) has no effect.");
    }

    MAX_NUM_VIRTUAL_TABLES = num;
}

function set_group_virtual_tables(const int table_ids[]) {
    open_container_virtual_table();

    use airgroup.std.vt alias vt;

    const int n = length(table_ids);
    if (n == 0) {
        error("The input group cannot be empty");
    }

    for (int i = 0; i < n; i++) {
        const int table_id = table_ids[i];
        // Check for inner duplicates
        for (int j = i + 1; j < n; j++) {
            if (table_id == table_ids[j]) {
                error(`The table_ids must be unique, found duplicate ${table_id}`);
            }
        }

        // Check for outter duplicates
        for (int j = 0; j < vt.num_groups; j++) {
            for (int k = 0; k < vt.group_len[j]; k++) {
                if (vt.group[j][k] == table_id) {
                    error(`The table_ids must be unique across groups, found duplicate ${table_id}`);
                }
            }
        }

        vt.group[vt.num_groups][vt.group_len[vt.num_groups]] = table_id;
        vt.group_len[vt.num_groups]++;
    }

    vt.num_groups++;
}

function collect_virtual_table(const int bus_id, const int table_id = -1, const expr table[]) {
    // If table_id is not specified, use bus_id
    if (table_id == -1) {
        table_id = bus_id;
    }

    // Check the width
    const int w = length(table);
    if (w == 0) {
        error(`Table #${table_id} on (AIRGROUP, AIR) = (${AIRGROUP_ID}, ${AIR_ID}) is empty`);
    } else if (w > MAX_VIRTUAL_TABLE_WIDTH) {
        error(`Table #${table_id} on (AIRGROUP, AIR) = (${AIRGROUP_ID}, ${AIR_ID}) exceeds maximum width`);
    }

    // Check the height
    const int h = Tables.num_rows(table[0]);
    if (h == 0) {
        error(`Table #${table_id} on (AIRGROUP, AIR) = (${AIRGROUP_ID}, ${AIR_ID}) is empty`);
    } 
    for (int i = 1; i < w; i++) {
        if (Tables.num_rows(table[i]) != h) {
            error(`Table #${table_id} on (AIRGROUP, AIR) = (${AIRGROUP_ID}, ${AIR_ID}) has inconsistent number of rows`);
        }
    }

    open_container_virtual_table();

    use airgroup.std.vt alias vt;

    int bus_id_pos = -1;
    for (int i = 0; i < vt.num_tables; i++) {
        if (vt.bus_id[i] == bus_id) {
            bus_id_pos = i;
            break;
        }
    }

    if (bus_id_pos == -1) {
        // The first time, we need to allocate a new entry
        for (int i = 0; i < w; i++) {
            vt.columns[vt.num_tables][0][i] = table[i];
        }
        vt.bus_id[vt.num_tables] = bus_id;
        vt.table_ids[vt.num_tables][0] = table_id;
        vt.inner_height[vt.num_tables][0] = h;
        vt.num_table_ids[vt.num_tables] = 1;
        vt.width[vt.num_tables] = w;
        vt.height[vt.num_tables] = h;
        vt.total_height += h;
        vt.num_tables++;
    } else {
        // Otherwise, update

        // If the table_id was already processed or is inconsistent, error
        const int num_table_ids = vt.num_table_ids[bus_id_pos];
        for (int i = 0; i < num_table_ids; i++) {
            if (vt.table_ids[bus_id_pos][i] == table_id) {
                error(`Table #${table_id} on (AIRGROUP, AIR) = (${AIRGROUP_ID}, ${AIR_ID}) was already processed`);
            } else if (vt.width[bus_id_pos] != w) {
                error(`Table #${table_id} on (AIRGROUP, AIR) = (${AIRGROUP_ID}, ${AIR_ID}) has inconsistent width: expected ${vt.width[bus_id_pos]}, got ${w}`);
            }
        }

        for (int i = 0; i < w; i++) {
            vt.columns[bus_id_pos][num_table_ids][i] = table[i];
        }
        vt.table_ids[bus_id_pos][num_table_ids] = table_id;
        vt.inner_height[bus_id_pos][num_table_ids] = h;
        vt.num_table_ids[bus_id_pos]++;
        vt.height[bus_id_pos] += h;
        vt.total_height += h;
    }

    // At the end, pack the tables
    on final(1) airgroup pack_tables();
}

function open_container_virtual_table() {
    container airgroup.std.vt {
        expr columns[ARRAY_SIZE][MAX_VIRTUAL_TABLE_IDS][MAX_VIRTUAL_TABLE_WIDTH];
        int bus_id[ARRAY_SIZE];
        int table_ids[ARRAY_SIZE][MAX_VIRTUAL_TABLE_IDS]; // One bus_id can be associated with multiple table_ids
        int inner_height[ARRAY_SIZE][MAX_VIRTUAL_TABLE_IDS];
        int num_table_ids[ARRAY_SIZE];
        int width[ARRAY_SIZE];
        int height[ARRAY_SIZE];
        int num_tables = 0;
        int total_height = 0;

        int group[MAX_VIRTUAL_TABLE_GROUPS][ARRAY_SIZE];
        int group_len[MAX_VIRTUAL_TABLE_GROUPS];
        int num_groups = 0;
    }
}

/*
    Given a set of tables Tᵢ := (uidᵢ, wᵢ, hᵢ), where  uidᵢ is the table uid, wᵢ is the width,
    and hᵢ is the height, this function packs the tables into a single table.

    The high-level idea is to first order the tables by width and then try to pack them
    assuming that:
      1. The height of the packing is a power of two.
      2. The only allowed operation is cutting the tables to stack them in some way.

    For example, if we have three tables T₁ = (0, 3, 2^10), T₂ = (1, 8, 2^4) and T₃ = (2, 4, 2^8), one option is to
    set the height to 2^9 and stack them as follows:
        =============================================================================================
         UID
        -------------------------                                            | #Fixed | #Witness(1) |
        | 0 | T₁[0] T₁[1] T₁[2] |                                            |   4    |      1      |
        ------------------------- ---> Bus                                   |        |             |
        -------------------------                                            |        |             |
        | 0 | T₁[0] T₁[1] T₁[2] |                                            |   4    |      1      |
        ------------------------- ---> Bus                                   |        |             |
        -------------------------------------------------------              |        |             |
        | 3 | T₃[0] T₃[1] T₃[2] T₃[3]   0     0     0     0   |              |   9    |      1      |
        | 2 | T₂[0] T₂[1] T₂[2] T₂[3] T₂[4] T₂[5] T₂[6] T₂[7] |              |        |             |
        | X |   0     0     0     0     0     0     0     0   |              |        |             |
        ------------------------------------------------------- ---> Bus     |        |             |
                                                                      Total: |   17   |      3      |
        =============================================================================================
    (NOTE: This is represented in vertical for space limitations, but the actual packing is horizontal)

    The size of the packing is chosen by trying to minimize the area of the resulting packing.
    Given the height of the resulting table T is H, the area of the packing is:
                        fixed_area   = H·∑ⱼ (1 + wⱼ) // UID + width
                        witness_area = H·((∑ⱼ 1) + 3 + 3*((∑ⱼ 1)//2)) // multiplicity + grand_sum + lookups_1
                        area         = fixed_area + witness_area
    where wⱼ is the width of the j-th group in the packing and ∑ⱼ 1 is the number of groups in the packing.

    NOTE: A table is never placed into two or more AIRs
*/
function pack_tables() {
    use airgroup.std.vt alias vt;

    // Compute the number of rows
    int num_rows = MAX_VIRTUAL_ROWS;
    if (num_rows == -1) {
        // Take the rows that makes the total height fit
        num_rows = 1;
        while (num_rows < vt.total_height) {
            num_rows *= 2;
        }
    }

    // Compute the number of virtual tables
    const int required_num_virtual_tables = (vt.total_height + num_rows - 1) / num_rows;
    const int min_num_virtual_tables = (vt.num_groups > 0) ? vt.num_groups : 1;
    if (min_num_virtual_tables > MAX_NUM_VIRTUAL_TABLES) {
        error(`The number of groups specified (${vt.num_groups}) exceeds the maximum number of virtual tables (${MAX_NUM_VIRTUAL_TABLES}). Consider increasing the maximum number of virtual tables via set_max_num_virtual_tables()`);
    }
    int num_virtual_tables = MAX_NUM_VIRTUAL_TABLES;
    if (required_num_virtual_tables < num_virtual_tables) {
        if (required_num_virtual_tables < min_num_virtual_tables) {
            // Respect minimum constraint
            println(`[Warning] The number of virtual tables required to fit the tables is ${required_num_virtual_tables}, but a minimum of ${min_num_virtual_tables} groups must be used. Using ${min_num_virtual_tables} instead.`);
            num_virtual_tables = min_num_virtual_tables;
        } else {
            // Reduce to what is actually required
            println(`[Warning] The number of virtual tables is ${MAX_NUM_VIRTUAL_TABLES}, but only ${required_num_virtual_tables} are required to fit the tables. Using ${required_num_virtual_tables} instead.`);
            num_virtual_tables = required_num_virtual_tables;
        }
    }

    // Order the tables by width in ascending order and then by height in descending order
    int ordered_tables[vt.num_tables];
    for (int i = 0; i < vt.num_tables; i++) {
        ordered_tables[i] = i;
    }
    for (int i = 0; i < vt.num_tables - 1; i++) {
        for (int j = i + 1; j < vt.num_tables; j++) {
            const int idx_i = ordered_tables[i];
            const int idx_j = ordered_tables[j];

            const int width_i = vt.width[idx_i];
            const int width_j = vt.width[idx_j];

            const int height_i = vt.height[idx_i];
            const int height_j = vt.height[idx_j];

            // Swap
            if ((width_i > width_j) || ((width_i == width_j) && (height_i < height_j))) {
                int tmp = ordered_tables[i];
                ordered_tables[i] = ordered_tables[j];
                ordered_tables[j] = tmp;
            }
        }
    }

    // Assign the tables to the virtual tables
    int ordered_tables_air[num_virtual_tables][vt.num_tables];
    int ordered_tables_air_height[num_virtual_tables];
    int ordered_tables_air_len[num_virtual_tables];

    // Map (ordered position) -> group index, -1 if ungrouped
    int table_group[vt.num_tables];
    int bus_group[vt.num_tables];
    for (int k = 0; k < vt.num_tables; k++) { 
        table_group[k] = -1; 
        bus_group[k] = -1;
    }

    // Initialize the tables with the already assigned groups
    for (int i = 0; i < vt.num_groups; i++) {
        const int group_len = vt.group_len[i];
        for (int j = 0; j < group_len; j++) {
            const int table_id = vt.group[i][j];

            // Find the table with this table_id
            int found = 0;
            for (int k = 0; k < vt.num_tables; k++) {
                const int idx = ordered_tables[k];
                for (int l = 0; l < vt.num_table_ids[idx]; l++) {
                    if (vt.table_ids[idx][l] == table_id) {
                        // Check bus (opid) grouping consistency
                        if (bus_group[idx] == -1) {
                            bus_group[idx] = i; // first time this bus appears
                        } else if (bus_group[idx] != i) {
                            error(`Table_id ${table_id} (opid ${vt.bus_id[idx]}) already assigned to group ${bus_group[idx]}, cannot also assign to group ${i}`);
                        }

                        table_group[k] = i;
                        found = 1;
                        break;
                    }
                }
                if (found == 1) break;
            }

            if (found == 0) {
                error(`The table_id ${table_id} specified in the group ${i} does not correspond to any virtual table`);
            }
        }
    }

    // Distribute ungrouped tables:
    //  - Keep user‑grouped tables already placed (preserve their relative order).
    //  - Append remaining tables in sorted order after the explicit group tables of that virtual table.
    //  - Respect the max height per virtual table except for the last one, which absorbs leftovers.
    const int max_height_by_table = (vt.total_height + num_virtual_tables - 1) / num_virtual_tables;
    int table_offset = 0;
    for (int i = 0; i < vt.num_tables; i++) {
        const int idx = ordered_tables[i];
        const int height = vt.height[idx];

        int target_vt = table_group[i];
        if (target_vt == -1) {
            // Ungrouped: choose best fit (least remaining space after placement)
            int best_vt = -1;
            int best_remaining = -1;
            for (int j = 0; j < num_virtual_tables; j++) {
                const int is_last = (j == num_virtual_tables - 1);
                int capacity = max_height_by_table - ordered_tables_air_height[j];
                if (is_last) {
                    capacity = 1 << 30; // effectively infinite spill
                }
                if (height <= capacity) {
                    const int remaining_after = capacity - height;
                    if (best_vt == -1 || remaining_after < best_remaining) {
                        best_vt = j;
                        best_remaining = remaining_after;
                        if (best_remaining == 0) break;
                    }
                }
            }
            if (best_vt == -1) {
                // Force into last
                best_vt = num_virtual_tables - 1;
            }
            target_vt = best_vt;
        }

        // Place into target virtual table
        ordered_tables_air[target_vt][ordered_tables_air_len[target_vt]] = idx;
        ordered_tables_air_height[target_vt] += height;
        ordered_tables_air_len[target_vt]++;
    }

    // Store the airgroup_ids and air_ids of the virtual tables
    container proof.std.vt {
        int airgroup_ids[num_virtual_tables];
        int air_ids[num_virtual_tables];
    }

    // Instantiate the virtual tables
    for (int i = 0; i < num_virtual_tables; i++) {
        const int total_height_air = ordered_tables_air_height[i];
        const int num_tables_air = ordered_tables_air_len[i];

        // Proceed with the packing
        const int num_groups = (total_height_air + num_rows - 1) / num_rows;
        if (num_groups > ARRAY_SIZE) {
            error(`The number of rows=${num_rows} set in the virtual table generates too many groups=${num_groups} > max_groups=${ARRAY_SIZE}. Consider setting more rows via set_max_num_rows_virtual()`);
        }

        // Compute the packing
        int uids_pack[num_groups][num_tables_air];
        int tables_pack[num_groups][num_tables_air];
        int widths_pack[num_groups];
        int lens_pack[num_groups];
        int used_area[num_groups];
        int available_height = num_rows;
        int offset = 0;
        for (int j = 0; j < num_tables_air; j++) {
            const int idx = ordered_tables_air[i][j];
            const int width = vt.width[idx];
            int height = vt.height[idx];

            while (height > 0) {
                if (height <= available_height) {
                    // It fits entirely
                    available_height -= height;
                    used_area[offset] += width * height;
                    height = 0;
                } else {
                    // Only part fits, so cut and place what we can
                    height -= available_height;
                    used_area[offset] += width * available_height;
                    available_height = 0;
                }

                // Update the uids and the number of tables in the current group
                tables_pack[offset][lens_pack[offset]] = idx;
                uids_pack[offset][lens_pack[offset]] = vt.bus_id[idx];
                lens_pack[offset]++;

                if (available_height == 0) {
                    // Close the current table
                    widths_pack[offset] = width; // Since they are ordered by width,
                                                    // the width representative is the last one that fits
                    offset++;

                    // Start a new table
                    available_height = num_rows;
                }
            }
        }

        // If the last table is partially filled, we need to add a complete new table
        if (available_height < num_rows) {
            widths_pack[offset] = vt.width[ordered_tables_air[i][num_tables_air - 1]];
        }

        // Compute the area of the packing (for debugging)
        int wasted_area = 0;
        int fixed_area = 0;
        for (int j = 0; j < num_groups; j++) {
            wasted_area += num_rows*widths_pack[j] - used_area[j];
            fixed_area += (1 + widths_pack[j]);
        }
        const int witness_area = (num_groups + 3 + 3 * (num_groups / 2));
        const int area = num_rows * (fixed_area + witness_area);
        // println(`Height: 2^${i}, Wasted area: ${wasted_area}, Fixed area: ${num_rows*fixed_area}, Witness area: ${num_rows*witness_area}, Area: ${area}, #Groups: ${num_groups}`);

        VirtualTable(num_rows, ordered_tables_air[i], num_tables_air, total_height_air, uids_pack, tables_pack, widths_pack, lens_pack, num_groups, i) alias `VirtualTable${i}`;
    }
}

airtemplate VirtualTable(const int N, const int tables[], const int num_tables, const int total_height, const int uids[][], const int table_idxs[][], const int widths[], const int lens[], const int num_groups, const int vt_idx) {    
    // Compute the number of fixed and witness columns
    int sum_widths = 0;
    for (int i = 0; i < num_groups; i++) {
        sum_widths += widths[i];
    }

    col fixed UID[num_groups];
    col fixed column[sum_widths];
    col witness multiplicity[num_groups];

    // Issue hint information
    int total_num_table_ids = 0;
    for (int i = 0; i < num_tables; i++) {
        const int idx = tables[i];
        total_num_table_ids += vt.num_table_ids[idx];
    }

    int flatten_table_ids[total_num_table_ids];
    int acc_heights[total_num_table_ids];
    int acc_total_height = 0;
    int offset = 0;
    println(`VirtualTable${vt_idx} instantiated with: N=2^${log2(N)}, #Fixed=${num_groups + sum_widths}, #Witness=${num_groups}`);
    println(`Table composition (total height of ${total_height}):`);
    for (int i = 0; i < num_tables; i++) {
        const int idx = tables[i];
        const int bus_id = vt.bus_id[idx];
        const int height = vt.height[idx];
        const int width = vt.width[idx];
        const int num_table_ids = vt.num_table_ids[idx];
        for (int j = 0; j < num_table_ids; j++) {
            const int table_id = vt.table_ids[idx][j];
            const int height = vt.inner_height[idx][j];
            flatten_table_ids[offset + j] = table_id;
            acc_heights[offset + j] = acc_total_height;
            acc_total_height += height;
            println(`   - Table ${table_id} with height=${height} and width=${width}`);
        }
        offset += num_table_ids;
    }
    @virtual_table_data{table_ids: flatten_table_ids, acc_heights: acc_heights, num_muls: num_groups};

    // Prove the groups
    int col_offset = 0;
    int table_id_offset = 0;
    int row_start = 0;
    for (int i = 0; i < num_groups; i++) {
        const int group_len = lens[i];
        const int group_width = widths[i];

        // println(`Proving group ${i} with #UIDs: ${group_len}, Width: ${group_width}`);
        int group_row_offset = 0;
        for (int j = 0; j < group_len; j++) {
            const int idx = table_idxs[i][j];
            const int height = vt.height[idx];
            const int width = vt.width[idx];
            const int uid = uids[i][j];

            // Fill the UID column
            const int height_remaining = height - row_start;
            const int N_remaining = N - group_row_offset;
            // Ensure the height does not exceed N
            const int h = (height_remaining <= N_remaining) ? height_remaining : N_remaining;
            Tables.fill(uid, UID[i], group_row_offset, h);

            // Fill the table columns
            const int num_table_ids = vt.num_table_ids[idx];
            // println(`Filling UID[${j}]: ${uid}, divided into ${num_table_ids} tables`);
            for (int k = table_id_offset; k < num_table_ids; k++) {
                const int height = vt.inner_height[idx][k];

                // Ensure the height does not exceed N
                const int height_remaining = height - row_start;
                const int N_remaining = N - group_row_offset;
                const int h = (height_remaining <= N_remaining) ? height_remaining : N_remaining;
                // println(`Filling with table ${vt.table_ids[idx][k]}, row ${group_row_offset} to ${group_row_offset + h}`);
                // println(`Table Height: ${height}, Table Height Remaining: ${height_remaining}, N: ${N}, N Remaining: ${N_remaining}, Table Rows: ${row_start} to ${row_start + h}`);

                for (int l = 0; l < width; l++) {
                    Tables.copy(vt.columns[idx][k][l], row_start, column[col_offset + l], group_row_offset, h);
                }

                // Update the row offset
                group_row_offset += h;

                // Update the row start
                if (height_remaining <= N_remaining) {
                    row_start = 0;
                    table_id_offset = 0;
                } else {
                    row_start += h;
                    table_id_offset = k;
                    break;
                }
            }
        }

        int uids_to_prove[group_len];
        for (int j = 0; j < group_len; j++) {
            uids_to_prove[j] = uids[i][j];
        }

        expr cols_to_prove[group_width];
        for (int j = 0; j < group_width; j++) {
            cols_to_prove[j] = column[col_offset + j];
        }

        // println(`Proving group ${i} with uids:`, uids_to_prove);

        // Perform the proving
        lookup_proves_dynamic(opids: uids_to_prove, busid: UID[i], expressions: cols_to_prove, mul: multiplicity[i]);

        // Update the column offset
        col_offset += group_width;
    }

    // save the airgroup id and air id of the table for latter use
    proof.std.vt.airgroup_ids[vt_idx] = AIRGROUP_ID;
    proof.std.vt.air_ids[vt_idx] = AIR_ID;

    on final proof issue_virtual_table_data_global();
}

private function issue_virtual_table_data_global() {
    use proof.std.vt;
    @virtual_table_data_global{airgroup_ids: airgroup_ids, air_ids: air_ids};
}