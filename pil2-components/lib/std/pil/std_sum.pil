require "std_constants.pil";
require "std_tools.pil";

// Note: When name is "isolated" we don't check if the number of columns is the same for all the PIOPs

function sum_assumes(const int name, const int opid, const expr cols[], const expr sel = 1, const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    update_piop_sum(name, 0, [opid], opid, sel, cols, direct_type);
}

function sum_proves(const int name, const int opid, const expr cols[], const expr mul = 1, const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    update_piop_sum(name, 1, [opid], opid, mul, cols, direct_type);
}

function sum(const int name, const int opid, const expr cols[], const expr mul = 1, const int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    update_piop_sum(name, 2, [opid], opid, mul, cols, direct_type);
}

function sum_assumes_dynamic(const int name, const int opid[], const expr sumid, const expr cols[], const expr sel = 1) {
    update_piop_sum(name, 0, opid, sumid, sel, cols);
}

private function init_proof_containers_sum(int name, int opid[]) {
    container proof.std.gsum {
        // Used for final checks
        int opids_count = 0;
        int opids[100];

        // Resulting sum of every airgroup and every air
        // It is the accumulation of each partial sum that each instance
        // of each air constributes to. It must be zero at the end.
        expr gsum = 0;

        // Direct shortcut to the previous sum
        int direct_gsum_nargs = 0;
        expr direct_gsum_s[100];
        expr direct_gsum_e[100];
    }

    // Container used for final checks
    for (int i = 0; i < length(opid); i++) {
        container proof.std.gsum.`id${opid[i]}` {
            int name = name;
            int cols;
            int proves = 0;
            int assumes = 0;
        }
    }
}

private function init_air_containers_sum(int name) {
    container air.std.gsum {
        int gsum_nargs = 0;
        expr gsum_s[100];
        expr gsum_e[100];
        int gsum_t[100]; // Used for optimization

        // Direct shortcut to the previous sum
        int direct_gsum_nargs = 0;
        expr direct_gsum_s[100];
        expr direct_gsum_e[100];
    }
}

private function initial_checks_sum(int proves, int opid[], int cols_count, int direct_type) {
    for (int i = 0; i < length(opid); i++) {
        // Assumes and proves of the same opid must have the same number of columns
        if (proof.std.gsum.`id${opid[i]}`.cols == 0) {
            // first time called
            proof.std.gsum.`id${opid[i]}`.cols = cols_count;

            // add opid on a list to verify at final
            proof.std.gsum.opids[proof.std.gsum.opids_count] = opid[i];
            proof.std.gsum.opids_count++;
        } else if (cols_count != proof.std.gsum.`id${opid[i]}`.cols) {
            const int expected_cols = proof.std.gsum.`id${opid[i]}`.cols;
            error(`The number of columns of PIOP #${opid[i]} must be ${expected_cols} but was ${cols_count}`);
        }

        // The same opid is shared among multiple instances of the same air, so we must keep track of the number of
        // proves and assumes to verify at the end that all of them match
        if (proves == 2) {
            // proves = 2 indicates the user is responsible for the use of proves and assumes
            // so we mark it as both a prove and an assume
            proof.std.gsum.`id${opid[i]}`.proves++;
            proof.std.gsum.`id${opid[i]}`.assumes++;
        } else {
            // otherwise, we mark it correctly
            const string name_str = proves ? "proves" : "assumes";
            proof.std.gsum.`id${opid[i]}`.`${name_str}`++;
        }
    }
}

/**
 * Given a selector sel and columns C₀,...,Cₙ₋₁, it:
 *      · 1] defines the running grandsum constraints for each air
 *      · 2] add each airgroupvalue of each airgroup to the running sum
 *      · 3] checks that the overall sum is zero
 * @param name name of the PIOP
 * @param proves boolean indicating if updating a proves or a assumes
 * @param opid (unique) identifier of the PIOP
 * @param sel selector of the PIOP
 * @param cols columns of the PIOP
 */
private function update_piop_sum(int name, int proves, int opid[], expr sumid, expr sel, expr cols[], int direct_type = PIOP_DIRECT_TYPE_DEFAULT) {
    const int cols_count = length(cols);
    if (cols_count < 1) {
        string side = proves ? "proves" : "assumes";
        error(`The number of columns in ${side} of ${name} #${opid} must be at least 1`);
    }

    init_proof_containers_sum(name, opid);

    if (direct_type == PIOP_DIRECT_TYPE_AIR || direct_type == PIOP_DIRECT_TYPE_DEFAULT) {
        init_air_containers_sum(name);
    }

    // Create debug hints for the witness computation
    string name_expr[cols_count];
    expr sum_expr = 0;
    for (int i = 0; i < cols_count; i++) {
        name_expr[i] = string(cols[i]);
        sum_expr += cols[i];
    }
    // proves = 2 marks that the user is responsible for the use of proves and assumes
    @gsum_member_data{name_piop: get_piop_name(name), name_expr: name_expr, opid: sumid, is_global: direct_type == PIOP_DIRECT_TYPE_GLOBAL,
                         proves: proves == 2 ? sel : proves, selector: sel, expressions: cols, deg_expr: degree(sum_expr), deg_sel: degree(sel)};

    initial_checks_sum(proves, opid, cols_count, direct_type);

    init_challenges();

    // selected vector to simple column reduction
    expr cols_compressed = compress_cols(sumid, cols);

    switch (direct_type) {
        case PIOP_DIRECT_TYPE_GLOBAL:
            gsum_update_global_constraint_data(proves, sel, cols_compressed);
        case PIOP_DIRECT_TYPE_AIR, PIOP_DIRECT_TYPE_DEFAULT:
            gsum_update_air_constraint_data(proves, sel, cols_compressed, direct_type);
        default:
            error("Invalid direct_type: ${direct_type}");
    }

    // Update global constraints
    on final proof piop_gsum_proof();
}

private function gsum_update_global_constraint_data(int proves, expr sel, expr cols_compressed) {
    use proof.std.gsum;

    direct_gsum_s[direct_gsum_nargs] = proves ? sel : 0 - sel;
    direct_gsum_e[direct_gsum_nargs] = cols_compressed;
    direct_gsum_nargs++;
}

private function gsum_update_air_constraint_data(int proves, expr sel, expr cols_compressed, int direct_type) {
    use air.std.gsum;

    if (direct_type == PIOP_DIRECT_TYPE_AIR) {
        direct_gsum_s[direct_gsum_nargs] = proves ? sel : 0 - sel;
        direct_gsum_e[direct_gsum_nargs] = cols_compressed;
        direct_gsum_nargs++;
    } else {
        gsum_s[gsum_nargs] = proves ? sel : 0 - sel;
        gsum_e[gsum_nargs] = cols_compressed;
        gsum_t[gsum_nargs] = proves;
        gsum_nargs++;

        // Additional processing for air constraints
        // TODO: Uncomment when expression comparison is implemented
        // on final air find_repeated_proves();

        // at the end, check consistency of all the opids
        on final proof check_opids_were_completed_sum();
    }

    // Define and update constraints at the air level
    on final air piop_gsum_air();

    // Define and update constraints at the airgroup level
    on final airgroup piop_gsum_airgroup();
}

/**
 * Look for repeated proves in the same air
 * Note: At this moment, it can only be optimized at the air level, but it would be more usefull to do it at the proof level
 */
private function find_repeated_proves() {
    use air.std.gsum;

    for (int i = 0; i < gsum_nargs; i++) {
        if (gsum_t[i] == 0) continue;
        for (int j = i + 1; j < gsum_nargs; j++) {
            if (gsum_t[j] == 0) continue;
            if (gsum_e[i] == gsum_e[j]) {
                println(`Proves of Lookups ${i} and ${j} are the same, consider merging them`);
            }
        }
    }

}

/**
 * It defines the constraints for the grandsum based on the logUp protocol https://eprint.iacr.org/2022/1530.pdf
 */
private function piop_gsum_air(const int blowupFactor = 2) {
    use air.std.gsum;

    col fixed __L1 = [1,0...]; // TODO: Fix

    col witness stage(2) gsum;

    airgroupval aggregate(sum) default(0) gsum_result;

    /*
                                            muli       seli
        gsum === 'gsum * (1 - L1) + ∑ᵢ ( -------- - -------- )
                                           ti + ɣ     fi + ɣ

    Note: The ti and fi are not necessarily related to each other
    */

    /*
      Transform the rational constraint to a polynomial one by substituting
      all the rational terms by terms of degree 1 (except for one to optimize):
            gsum === 'gsum * (1 - L1) + ∑ᵢ imi + num / den
    */
    int low_degree_term[gsum_nargs];
    int high_degree_term[gsum_nargs];
    int low_degree_len = 0;
    int high_degree_len = 0;
    int isolated_term = -1;
    for (int i = 0; i < gsum_nargs; i++) {
        const int gsum_s_degree = degree(gsum_s[i]);
        const int gsum_e_degree = degree(gsum_e[i]);
        if (gsum_s_degree == 0 && gsum_e_degree == 0) {
            // In the case that both the numerator and the denominator are constants, 
            // we can directly add them through the direct terms
            direct_gsum_s[direct_gsum_nargs] = gsum_s[i];
            direct_gsum_e[direct_gsum_nargs] = gsum_e[i];
            direct_gsum_nargs++;
        } 
        else if ((gsum_s_degree == 3 && gsum_e_degree == 1) ||
                (gsum_s_degree == 2 && gsum_e_degree == 1)) {
            // Identify isolated terms of specific degrees
            isolated_term = i;
        } 
        else if (gsum_s_degree > 2 || gsum_e_degree > 1) {
            // Track high-degree terms
            high_degree_term[high_degree_len] = i;
            high_degree_len++;
        } 
        else {
            // Handle low-degree terms
            if (isolated_term == -1) {
                // The first low-degree term is isolated
                isolated_term = i;
            } else {
                low_degree_term[low_degree_len] = i;
                low_degree_len++;
            }
        }
    }

    expr sum_ims = 0;
    // Create an intermediate for clusters of low-degree terms so that
    // the degree of the constraint is lower than the maximum allowed
    if (low_degree_len > 0) {
        const int nIm = low_degree_len/blowupFactor;

        col witness stage(2) im[nIm];

        for (int i = 0; i < nIm; i++) {

            //              s[3*i]            s[3*i+1]            s[3*i+2]
            // im[i] = --------------- + ----------------- + -----------------
            //              e[3*i]            e[3*i+1]            e[3*i+2]
            // where:
            // s[x] = mul[x]  if the x-th term is a prove,
            // s[x] = -sel[x] if the x-th term is an assume,
            // e[x] = (t[x] + ɣ) if the x-th term is a prove,
            // e[x] = (f[x] + ɣ) if the x-th term is an assume,

            expr prods = 1;
            expr sums = 0;
            for (int j = 0; j < blowupFactor; j++) {
                prods *= (gsum_e[low_degree_term[blowupFactor * i + j]] + std_gamma);

                expr _partial = gsum_s[low_degree_term[blowupFactor * i + j]];
                for (int k = 0; k < blowupFactor; k++) {
                    if (k == j) continue;
                    _partial *= (gsum_e[low_degree_term[blowupFactor * i + k]] + std_gamma);
                }
                sums += _partial;
            }
            @im_col{reference: im[i], numerator: sums, denominator: prods};

            // im[i] * t[3*i] * t[3*i+1] * t[3*i+2] ===
            //                    mul[3*i]*t[3*i+1]*t[3*i+2] + mul[3*i+1]*t[3*i]*t[3*i+2] + mul[3*i+2]*t[3*i]*t[3*i+1];
            im[i] * prods === sums;

            sum_ims += im[i];
        }

        const int nRemTerms = low_degree_len % blowupFactor;
        // If there are remaining terms, add an extra cluster
        if (nRemTerms != 0) {
            col witness stage(2) im_extra;

            expr prods = 1;
            expr sums = 0;
            for (int j = 0; j < nRemTerms; j++) {
                prods *= (gsum_e[low_degree_term[blowupFactor * nIm + j]] + std_gamma);

                expr _partial = gsum_s[low_degree_term[blowupFactor * nIm + j]];
                for (int k = 0; k < nRemTerms; k++) {
                    if (k == j) continue;
                    _partial *= (gsum_e[low_degree_term[blowupFactor * nIm + k]] + std_gamma);
                }
                sums += _partial;
            }
            @im_col{reference: im_extra, numerator: sums, denominator: prods};

            im_extra * prods === sums;

            sum_ims += im_extra;
        }
    }

    // Create a single intermediate for all the high-degree terms
    if (high_degree_len > 0) {
        /*
                      s[i]   
           im[i] = ----------
                    e[i] + ɣ  
        */
        col witness stage(2) im_high_degree[high_degree_len];

        for (int i = 0; i < high_degree_len; i++) {
            const int index = high_degree_term[i];

            @im_col{reference: im_high_degree[i], numerator: gsum_s[index], denominator: gsum_e[index] + std_gamma};

            im_high_degree[i] * (gsum_e[index] + std_gamma) === gsum_s[index];
            sum_ims += im_high_degree[i];
        }
    }

    // Compute the isolated term numerator and denominator
    expr isolated_num = 0;
    expr isolated_den = 1;
    if (isolated_term != -1) {
        isolated_den = (gsum_e[isolated_term] + std_gamma);
        isolated_num = gsum_s[isolated_term];
    }

    /*
     At this point, the constraint has been transformed to:
          gsum === 'gsum * (1 - L1) + ∑ᵢ imᵢ + num / den

     Now, we whould add the direct terms to the constraint:
          gsum === 'gsum * (1 - L1) + ∑ᵢ imᵢ + num / den + ∑ⱼ sⱼ / (eⱼ + ɣ)
     where both sⱼ and eⱼ are field elements, for all j.

     We rewrite it as:
          ((gsum - 'gsum * (1 - L1) - ∑ᵢ imᵢ)·den - num)·∏ⱼ (eⱼ + ɣ) - den·∑ⱼ sⱼ·∏ₖ≠ⱼ (eₖ + ɣ) === 0
    */

    // Compute the direct terms numerator and denominator
    expr direct_num = 0;
    expr direct_den = 1;
    for (int i = 0; i < direct_gsum_nargs; i++) {
        direct_den *= (direct_gsum_e[i] + std_gamma);

        expr _tmp = direct_gsum_s[i];
        for (int j = 0; j < direct_gsum_nargs; j++) {
            if (j != i) _tmp *= (direct_gsum_e[j] + std_gamma);
        }
        direct_num += _tmp;
    }

    expr hint_den = direct_den * isolated_den;
    expr hint_num = sum_ims * hint_den + direct_num * isolated_den + isolated_num * direct_den;
    @gsum_col{reference: gsum, numerator: hint_num, denominator: hint_den, result: gsum_result};

    ((gsum - 'gsum * (1 - __L1) - sum_ims) * isolated_den - isolated_num) * direct_den - isolated_den * direct_num === 0;
    __L1' * (gsum - gsum_result) === 0;
}

// Note: We don't "update" the sum at the airgroup level (i.e., all the resulting sums generated by each air)
//       because we don't know how many airs will be generated at compile time. Therefore we use the same
//       term to refer to both things: the value generated at each air and the value generated at each airgroup.
//       It is like jumping from the air level to the proof (global) level, from the constraint point of view.

/**
 * It updates the expression for the grandsum at the proof level
 */
private function piop_gsum_airgroup() {
    // The `gsum_result` from each airgroup is added to the overall global sum
    proof.std.gsum.gsum += gsum_result;
}

/**
 * It It updates the expression for the grandsum at the proof level directly
 */
private function piop_gsum_proof() {
    use proof.std.gsum;

    //           s_1        s_2          s_3
    // gsum + -------- + --------- + ---------- === 0
    //           e_1        e_2          e_3
    // where:
    // s_i = mul_i  if the i-th term is a prove,
    // s_i = -sel_i if the i-th term is an assume,
    // e_i = (t_i + ɣ) if the i-th term is a prove,
    // e_i = (f_i + ɣ) if the i-th term is an assume,
    //
    // We rewrite it as:
    //      gsum·e_1·e_2·e_3 + s_1·e_2·e_3  + s_2·e_1·e_3 + s_3·e_1·e_2 === 0
    //
    // Note: We cannot update this constraint directly if some of the elements
    //       are not globally defined: constants, public inputs, airgroupvalues, ...

    expr global_num = 0;
    expr global_den = 1;
    for (int i = 0; i < direct_gsum_nargs; i++) {
        global_den *= (direct_gsum_e[i] + std_gamma);

        expr _tmp = direct_gsum_s[i];
        for (int j = 0; j < direct_gsum_nargs; j++) {
            if (j != i) _tmp *= (direct_gsum_e[j] + std_gamma);
        }
        global_num += _tmp;
    }

    gsum * global_den + global_num === 0;
}

/**
 * It checks that all the assumes and proves of the same opid have been defined
 */
private function check_opids_were_completed_sum() {
    for (int i = 0; i < proof.std.gsum.opids_count; i++) {
        int opid = proof.std.gsum.opids[i];
        use proof.std.gsum.`id${opid}`;

        // If the PIOP is isolated, avoid any check
        if (name == PIOP_NAME_ISOLATED) continue;

        const string name_str = get_piop_name(name);

        // At least one assume and one prove must be defined
        if (assumes == 0) {
            error(`${name_str} #${opid} defined without assume`);
        } else if (proves == 0) {
            error(`${name_str} #${opid} defined without proves`);
        }
    }
}