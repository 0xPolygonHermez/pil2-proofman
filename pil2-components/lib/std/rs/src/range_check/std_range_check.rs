use core::panic;
use std::{fmt::Debug, sync::Arc};

use p3_field::PrimeField64;

use witness::WitnessComponent;
use proofman_common::{ProofCtx, SetupCtx};
use proofman_hints::{
    get_hint_field_gc_constant_a, get_hint_field_constant, get_hint_ids_by_name, HintFieldOptions, HintFieldValue,
};

use crate::{
    extract_field_element_as_usize, get_global_hint_field_constant_as, get_hint_field_constant_as_field,
    get_hint_field_constant_as_u64, validate_binary_field, AirComponent, SpecifiedRanges, U16Air, U8Air,
};

#[derive(Debug, Clone)]
pub struct StdRange {
    pub opid: u64,
    rc_type: StdRangeType,
    pub data: RangeData,
}

#[derive(Debug, Clone)]
pub enum StdRangeType {
    U8Air,
    U16Air,
    U8AirDouble,
    U16AirDouble,
    SpecifiedRanges,
}

#[derive(Debug, PartialEq, Clone)]
pub struct RangeData {
    pub min: i64,
    pub max: i64,
    pub predefined: bool,
}

pub struct StdRangeCheck<F: PrimeField64> {
    _phantom: std::marker::PhantomData<F>,
    ranges: Vec<StdRange>,
    pub u8air: Option<Arc<U8Air>>,
    pub u16air: Option<Arc<U16Air>>,
    pub specified_ranges_air: Option<Arc<SpecifiedRanges>>,
}

impl<F: PrimeField64> StdRangeCheck<F> {
    pub fn new(pctx: Arc<ProofCtx<F>>, sctx: &SetupCtx<F>) -> Arc<Self> {
        // Find which range check related AIRs need to be instantiated
        let u8air_hint = get_hint_ids_by_name(sctx.get_global_bin(), "u8air");
        let u16air_hint = get_hint_ids_by_name(sctx.get_global_bin(), "u16air");
        let specified_ranges_air_hint = get_hint_ids_by_name(sctx.get_global_bin(), "specified_ranges");

        // Instantiate the AIRs
        let u8air = create_air::<U8Air, F>(&pctx, sctx, &u8air_hint);
        let u16air = create_air::<U16Air, F>(&pctx, sctx, &u16air_hint);
        let specified_ranges_air = create_air::<SpecifiedRanges, F>(&pctx, sctx, &specified_ranges_air_hint);

        // Get the number of specified ranges
        let num_specified_ranges = if specified_ranges_air_hint.is_empty() {
            0
        } else {
            get_global_hint_field_constant_as(sctx, specified_ranges_air_hint[0], "opids_count")
        };

        // Process range check users
        let mut ranges = vec![
            StdRange {
                opid: 0,
                rc_type: StdRangeType::U8Air,
                data: RangeData { min: 0, max: 0, predefined: false },
            };
            num_specified_ranges + 4
        ];
        let mut processed_specified_ranges = 0;
        if let Some(std_rc_users) = get_hint_ids_by_name(sctx.get_global_bin(), "std_rc_users").first() {
            let num_users = get_global_hint_field_constant_as(sctx, *std_rc_users, "num_users");
            let airgroup_ids = get_hint_field_gc_constant_a(sctx, *std_rc_users, "airgroup_ids", false);
            let air_ids = get_hint_field_gc_constant_a(sctx, *std_rc_users, "air_ids", false);

            for i in 0..num_users {
                let airgroup_id = extract_field_element_as_usize(&airgroup_ids.values[i], "airgroup_id");
                let air_id = extract_field_element_as_usize(&air_ids.values[i], "air_id");

                // Register the ranges generated by the user
                Self::register_ranges(
                    sctx,
                    airgroup_id,
                    air_id,
                    &mut ranges,
                    num_specified_ranges,
                    &mut processed_specified_ranges,
                );
            }
        }

        return Arc::new(Self { _phantom: std::marker::PhantomData, ranges, u8air, u16air, specified_ranges_air });

        // Helper function to instantiate AIRs
        fn create_air<T, F: PrimeField64>(pctx: &ProofCtx<F>, sctx: &SetupCtx<F>, hints: &[u64]) -> Option<Arc<T>>
        where
            T: AirComponent<F>,
        {
            if hints.is_empty() {
                return None;
            }
            let airgroup_id = get_global_hint_field_constant_as(sctx, hints[0], "airgroup_id");
            let air_id = get_global_hint_field_constant_as(sctx, hints[0], "air_id");
            Some(T::new(pctx, sctx, Some(airgroup_id), Some(air_id)))
        }
    }

    fn register_ranges(
        sctx: &SetupCtx<F>,
        airgroup_id: usize,
        air_id: usize,
        ranges: &mut [StdRange],
        num_specified_ranges: usize,
        processed_specified_ranges: &mut usize,
    ) {
        let setup = sctx.get_setup(airgroup_id, air_id);

        // Obtain info from the range hints
        let rc_hints = get_hint_ids_by_name(setup.p_setup.p_expressions_bin, "range_def");

        for hint in rc_hints {
            let opid = get_hint_field_constant_as_u64::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "opid",
                HintFieldOptions::default(),
            );

            let predefined = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "predefined",
                HintFieldOptions::default(),
            );

            let min = get_hint_field_constant_as_u64::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "min",
                HintFieldOptions::default(),
            );

            let min_neg = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "min_neg",
                HintFieldOptions::default(),
            );

            let max = get_hint_field_constant_as_u64::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "max",
                HintFieldOptions::default(),
            );

            let max_neg = get_hint_field_constant_as_field::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "max_neg",
                HintFieldOptions::default(),
            );

            let HintFieldValue::String(rc_type) = get_hint_field_constant::<F>(
                sctx,
                airgroup_id,
                air_id,
                hint as usize,
                "type",
                HintFieldOptions::default(),
            ) else {
                tracing::error!("Type hint must be a string");
                panic!();
            };

            let predefined = validate_binary_field(predefined, "Predefined");
            let min_neg = validate_binary_field(min_neg, "Min neg");
            let max_neg = validate_binary_field(max_neg, "Max neg");

            let min = if min_neg { min as i128 - F::ORDER_U64 as i128 } else { min as i128 };

            // Check that min does not overflow 63 bits
            if min > i64::MAX as i128 {
                tracing::error!("Min value is too large");
                panic!();
            }

            let max = if max_neg { max as i128 - F::ORDER_U64 as i128 } else { max as i128 };

            // Check that max does not overflow 63 bits
            if max > i64::MAX as i128 {
                tracing::error!("Max value is too large");
                panic!();
            }

            let data = RangeData { min: min as i64, max: max as i64, predefined };

            // If the range is already defined, skip
            if ranges.iter().any(|r| r.data == data) {
                continue;
            }

            // Otherwise, define the range
            let (rc_type, idx) = match rc_type.as_str() {
                "U8" => (StdRangeType::U8Air, num_specified_ranges),
                "U16" => (StdRangeType::U16Air, num_specified_ranges + 1),
                "U8Double" => (StdRangeType::U8AirDouble, num_specified_ranges + 2),
                "U16Double" => (StdRangeType::U16AirDouble, num_specified_ranges + 3),
                "Specified" => {
                    let idx = *processed_specified_ranges;
                    *processed_specified_ranges += 1;
                    (StdRangeType::SpecifiedRanges, idx)
                }
                _ => panic!("Invalid range check type: {rc_type}"),
            };

            ranges[idx] = StdRange { opid, rc_type, data };
        }
    }

    pub fn get_range(&self, min: i64, max: i64, predefined: Option<bool>) -> usize {
        // Default predefined value in STD is false
        let predefined = predefined.unwrap_or(false);

        // Find the range with the given [min,max] values, return its id
        let received_range_data = RangeData { min, max, predefined };
        if let Some(i) = self.ranges.iter().position(|r| r.data == received_range_data) {
            i
        } else {
            // If the range was not computed in the setup phase, error
            let name = if predefined { "Predefined" } else { "Specified" };
            tracing::error!("{name} range not found: [min,max] = [{},{}]", min, max);
            panic!();
        }
    }

    pub fn assign_values(&self, value: i64, multiplicity: u64, id: usize) {
        // Find the range with the given id
        let range_item = &self.ranges[id];

        // If verify-rc-values is activated and in non-release build, check that the value is contained within the range
        #[cfg(all(debug_assertions, feature = "verify-rc-values"))]
        check_value_in_range(value, range_item);

        // Update the multiplicity of the corresponding AIR
        match range_item.rc_type {
            StdRangeType::U8Air => {
                // Here, we can safely assume that value ∊ [0,2⁸-1]
                // Therefore, we can safely cast value to u8
                self.u8air.as_ref().unwrap().update_inputs(value as u8, multiplicity);
            }
            StdRangeType::U16Air => {
                // Here, we can safely assume that value ∊ [0,2¹⁶-1]
                // Therefore, we can safely cast value to u16
                self.u16air.as_ref().unwrap().update_inputs(value as u16, multiplicity);
            }
            StdRangeType::U8AirDouble => {
                // Here, we can safely assume that value ∊ [0,2⁸-1], min >= 0 and max <= 2⁸-1
                // Therefore, we can safely cast value to u8
                let range_data = &range_item.data;
                let lower_value = (value - range_data.min) as u8;
                let upper_value = (range_data.max - value) as u8;
                let u8_air = self.u8air.as_ref().unwrap();
                u8_air.update_inputs(lower_value, multiplicity);
                u8_air.update_inputs(upper_value, multiplicity);
            }
            StdRangeType::U16AirDouble => {
                // Here, we can safely assume that value ∊ [0,2¹⁶-1], min >= 0 and max <= 2¹⁶-1
                // Therefore, we can safely cast value to u16
                let range_data = &range_item.data;
                let lower_value = (value - range_data.min) as u16;
                let upper_value = (range_data.max - value) as u16;
                let u16_air = self.u16air.as_ref().unwrap();
                u16_air.update_inputs(lower_value, multiplicity);
                u16_air.update_inputs(upper_value, multiplicity);
            }
            StdRangeType::SpecifiedRanges => {
                self.specified_ranges_air.as_ref().unwrap().update_inputs(id, value, multiplicity);
            }
        }

        #[cfg(all(debug_assertions, feature = "verify-rc-values"))]
        fn check_value_in_range(value: i64, range: &StdRange) {
            let min = range.data.min;
            let max = range.data.max;
            if value < min || value > max {
                log::error!("Value {} is not in the range [min,max] = [{},{}]", value, min, max);
                panic!("Range check failed");
            }
        }
    }
}

impl<F: PrimeField64> WitnessComponent<F> for StdRangeCheck<F> {}
