// WARNING: This file has been autogenerated from the PILOUT file.
// Manual modifications are not recommended and may be overwritten.
#![allow(clippy::all)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]

use proofman_common as common;
use proofman_common::GenericTrace;
use proofman_common::PackedInfoConst;
pub use proofman_macros::trace_row;
pub use proofman_macros::values;
use fields::PrimeField64;
use std::fmt;

#[allow(dead_code)]
type FieldExtension<F> = [F; 3];

pub const PILOUT_HASH: &str = "{pilout_hash}";

//AIRGROUP CONSTANTS
{{ for constant in constant_airgroups }}
pub const { constant.0 }_AIRGROUP_ID: usize = { constant.1 };
{{ endfor }}
//AIR CONSTANTS
{{ for constant in constant_airs }}
pub const { constant.0 }_AIR_IDS: &[usize] = &[{ constant.3 }];
{{ endfor }}
{{ for public_values in publics }}
//PUBLICS
use serde::Deserialize;
use serde::Serialize;
use serde_arrays;

{{ for column in public_values.values_u64 }}{{ if column.array }}
fn default_array_{column.name}() -> {column.type} \{
    {column.type_default}
}
{{endif}}{{ endfor }}

#[derive(Debug, Serialize, Deserialize)]
pub struct {project_name}Publics \{
    {{ for column in public_values.values_u64 }}{{ if column.array }}#[serde(default = "default_array_{column.name}", with = "serde_arrays")]{{ else }}#[serde(default)]{{ endif }}
    pub {column.name}: {column.type},
    {{ endfor }}
}

impl Default for {project_name}Publics \{
    fn default() -> Self \{
        Self \{ {{ for column in public_values.values_default }} 
            {column.name}: {column.type}, {{ endfor }}
        }
    }
}

values!({ project_name }PublicValues<F> \{
{{ for column in public_values.values }} { column.name }: { column.type },{{ endfor }}
});
{{ endfor }} {{ for proof_vals in proof_values  }}
values!({ project_name }ProofValues<F> \{
{{ for column in proof_vals.values }} { column.name }: { column.type },{{ endfor }}
});
{{ endfor }} {{ for air_group in air_groups }}{{ for air in air_group.airs }}
trace_row!({ air.name }FixedRow<F> \{
{{ for column in air.fixed }} { column.name }: { column.type },{{ endfor }}
});
pub type { air.name }Fixed<F> = GenericTrace<{ air.name }FixedRow<F>, { air.num_rows }, { air_group.airgroup_id }, { air.id }>;

trace_row!({ air.name }TraceRow<F> \{
{{ for column in air.columns }} { column.name }:{{ if air.has_packed }}{ column.type_packed }{{ else }}{ column.type }{{ endif }},{{ endfor }}
});
pub type { air.name }Trace<F> = GenericTrace<{ air.name }TraceRow<F>, { air.num_rows }, { air_group.airgroup_id }, { air.id }>;

{{ if air.has_packed }}
pub type { air.name }TracePacked<F> = GenericTrace<{ air.name }TraceRowPacked<F>, { air.num_rows }, { air_group.airgroup_id }, { air.id }>;

{{ endif }}{{ endfor }}{{ endfor }}{{ for air_group in air_groups }}{{ for air in air_group.airs }}{{ for custom_commit in air.custom_columns  }}
trace_row!({ air.name }{custom_commit.name}TraceRow<F> \{
{{ for column in custom_commit.custom_columns }} { column.name }: { column.type },{{ endfor }}
});
pub type { air.name }{custom_commit.name}Trace<F> = GenericTrace<{ air.name }{custom_commit.name}TraceRow<F>, { air.num_rows }, { air_group.airgroup_id }, { air.id }, { custom_commit.commit_id }>;

{{ endfor }}{{ endfor }}{{ endfor }}{{ for air_group in air_groups }}{{ for air in air_group.airs }}{{ for air_values in air.air_values  }}
values!({ air.name }AirValues<F> \{
{{ for column in air_values.values }} { column.name }: { column.type },{{ endfor }}
});
{{ endfor }}{{ endfor }}{{ endfor }}{{ for air_group in air_groups }}{{ for air in air_group.airs }}{{ for air_groupvalues in air.airgroup_values  }}
values!({ air.name }AirGroupValues<F> \{
{{ for column in air_groupvalues.values }} { column.name }: { column.type },{{ endfor }}
});
{{ endfor }}{{ endfor }}{{ endfor }}
pub const PACKED_INFO: &[(usize, usize, PackedInfoConst)] = &[{{ for item in packed_info }}
    ({ item.airgroup_id }, { item.air_id }, PackedInfoConst \{
        is_packed: { item.is_packed },
        num_packed_words: { item.num_packed_words },
        unpack_info: &[{ item.unpack_info }],
    }),{{ endfor }}
];